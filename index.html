<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• LIVE HAND PARTICLE CONTROL</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        #container {
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #webcamContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 3px solid #00ff88;
            border-radius: 15px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 30px #00ff88;
        }
        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            display: block;
        }
        #handOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff00ff;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .title {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 22px;
            text-shadow: 0 0 10px #00ffff;
        }
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        .mode-btn {
            padding: 12px 5px;
            background: linear-gradient(45deg, #0066cc, #6600cc);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.5);
        }
        .mode-btn.active {
            background: linear-gradient(45deg, #00ff88, #0088ff);
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px #00ff88;
        }
        .control-section {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 40, 80, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .control-label {
            width: 100px;
            color: #88ffff;
            font-size: 14px;
        }
        .slider-container {
            flex: 1;
            margin: 0 10px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, #0066cc, #cc00cc);
            border-radius: 3px;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 10px #00ff88;
        }
        .value-display {
            width: 50px;
            text-align: right;
            color: #ff88ff;
            font-weight: bold;
            font-size: 14px;
        }
        .hand-tracker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120px;
            height: 120px;
            pointer-events: none;
            z-index: 50;
            transform: translate(-50%, -50%);
            display: none;
        }
        .tracker-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        .tracker-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            filter: drop-shadow(0 0 10px white);
        }
        .stats-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 10, 30, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            max-width: 280px;
        }
        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        .stat-label {
            color: #88ff88;
        }
        .stat-value {
            color: #ffff88;
            font-weight: bold;
        }
        .fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #00ff88;
        }
        .gesture-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            opacity: 0;
            pointer-events: none;
            z-index: 60;
            transition: all 0.5s;
        }
        .camera-status {
            position: absolute;
            top: 20px;
            right: 150px;
            color: #ffaa00;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #ffaa00;
        }
        .hand-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            pointer-events: none;
            z-index: 70;
            display: none;
        }
        .debug-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="mainCanvas"></canvas>
        
        <div id="webcamContainer">
            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="handOverlay"></canvas>
        </div>
        
        <div class="control-panel">
            <div class="title">üëã LIVE HAND CONTROL</div>
            
            <div class="mode-grid">
                <button class="mode-btn active" onclick="setMode('flow')">üåÄ FLOW</button>
                <button class="mode-btn" onclick="setMode('attract')">‚úä ATTRACT</button>
                <button class="mode-btn" onclick="setMode('repel')">üñêÔ∏è REPEL</button>
                <button class="mode-btn" onclick="setMode('swirl')">üå™Ô∏è SWIRL</button>
                <button class="mode-btn" onclick="setMode('rainbow')">üåà RAINBOW</button>
                <button class="mode-btn" onclick="setMode('explode')">üí• EXPLODE</button>
            </div>
            
            <div class="control-section">
                <div class="control-row">
                    <div class="control-label">Particles</div>
                    <div class="slider-container">
                        <input type="range" id="particleSlider" min="1000" max="10000" value="3000" step="500">
                    </div>
                    <div class="value-display" id="particleValue">3000</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">Power</div>
                    <div class="slider-container">
                        <input type="range" id="powerSlider" min="0.1" max="3.0" value="1.0" step="0.1">
                    </div>
                    <div class="value-display" id="powerValue">1.0</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">Size</div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="0.5" max="5.0" value="2.0" step="0.1">
                    </div>
                    <div class="value-display" id="sizeValue">2.0</div>
                </div>
            </div>
        </div>
        
        <div class="hand-tracker" id="handTracker">
            <div class="tracker-circle"></div>
            <div class="tracker-emoji">üëã</div>
        </div>
        
        <div class="hand-point" id="handPoint"></div>
        
        <div class="gesture-popup" id="gesturePopup">üëã</div>
        
        <div class="stats-panel">
            <div class="stat-item">
                <span class="stat-label">Camera Status:</span>
                <span class="stat-value" id="cameraStatus">OFF</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Hand Detected:</span>
                <span class="stat-value" id="handStatus">NO</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Gesture:</span>
                <span class="stat-value" id="gestureType">NONE</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">X Position:</span>
                <span class="stat-value" id="posX">0.00</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Y Position:</span>
                <span class="stat-value" id="posY">0.00</span>
            </div>
        </div>
        
        <div class="fps-counter">FPS: <span id="fpsValue">0</span></div>
        <div class="camera-status" id="cameraStatusText">üé• Camera Starting...</div>
    </div>

    <!-- Three.js only -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            particles: {
                count: 3000,
                size: 2.0,
                power: 1.0,
                attraction: 0.02,
                repulsion: 0.015,
                friction: 0.96
            },
            camera: {
                distance: 35,
                smoothness: 0.1
            },
            hand: {
                smoothing: 0.2,
                detectionThreshold: 500,
                skinColor: {
                    r: { min: 100, max: 255 },
                    g: { min: 50, max: 200 },
                    b: { min: 0, max: 150 }
                }
            }
        };

        // ========== GLOBAL VARIABLES ==========
        let scene, camera, renderer;
        let particleSystem;
        let particles = [];
        let currentMode = 'flow';
        let time = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Webcam and hand tracking
        let video;
        let handCanvas;
        let handCtx;
        let handPosition = { x: 0.5, y: 0.5 };
        let lastHandPosition = { x: 0.5, y: 0.5 };
        let handVelocity = { x: 0, y: 0 };
        let currentGesture = 'none';
        let isHandDetected = false;
        let lastGestureTime = 0;
        let cameraActive = false;

        // ========== INITIALIZE THREE.JS ==========
        function initThreeJS() {
            // Create scene with fog
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 100);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camera.distance);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Point light that follows hand
            const pointLight = new THREE.PointLight(0x00ffff, 1.5, 50);
            pointLight.position.set(0, 0, 20);
            scene.add(pointLight);
            window.pointLight = pointLight;
            
            // Create particle system
            createParticleSystem();
            
            updateStatus('Camera', 'STARTING');
        }

        // ========== CREATE PARTICLE SYSTEM ==========
        function createParticleSystem() {
            // Remove old system if exists
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
            }
            
            // Initialize particles
            particles = [];
            const positions = new Float32Array(CONFIG.particles.count * 3);
            const colors = new Float32Array(CONFIG.particles.count * 3);
            const sizes = new Float32Array(CONFIG.particles.count);
            
            for (let i = 0; i < CONFIG.particles.count; i++) {
                // Create spherical distribution
                const radius = Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                particles.push({
                    x, y, z,
                    vx: 0, vy: 0, vz: 0,
                    originalX: x,
                    originalY: y,
                    originalZ: z,
                    size: Math.random() * 0.8 + 0.3,
                    color: new THREE.Color(),
                    phase: Math.random() * Math.PI * 2
                });
                
                // Set initial positions
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Set colors based on position
                const hue = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);
                particles[i].color.setHSL(hue, 0.9, 0.5);
                
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
                
                sizes[i] = particles[i].size * CONFIG.particles.size;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: CONFIG.particles.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            updateStatus('Hand', `${CONFIG.particles.count} particles created`);
        }

        // ========== INITIALIZE WEBCAM WITH HAND DETECTION ==========
        async function initWebcam() {
            try {
                updateStatus('Camera', 'REQUESTING ACCESS...');
                
                video = document.getElementById('webcam');
                
                // Get camera access with better resolution
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                // Setup hand canvas for drawing
                handCanvas = document.getElementById('handOverlay');
                handCtx = handCanvas.getContext('2d');
                handCanvas.width = video.videoWidth;
                handCanvas.height = video.videoHeight;
                
                cameraActive = true;
                updateStatus('Camera', 'ACTIVE ‚úÖ');
                document.getElementById('cameraStatusText').textContent = "üé• Camera Active";
                document.getElementById('cameraStatusText').style.borderColor = "#00ff88";
                document.getElementById('cameraStatusText').style.color = "#00ff88";
                
                // Start hand detection
                startHandDetection();
                
            } catch (error) {
                console.error('Webcam error:', error);
                updateStatus('Camera', 'ERROR ‚ùå');
                document.getElementById('cameraStatusText').textContent = "üé• Camera Failed";
                document.getElementById('cameraStatusText').style.borderColor = "#ff0000";
                document.getElementById('cameraStatusText').style.color = "#ff0000";
                
                // Fallback to mouse control
                setupMouseControl();
            }
        }

        // ========== SIMPLE HAND DETECTION ==========
        function startHandDetection() {
            // Create a buffer for motion detection
            let lastFrame = null;
            
            function detectHand() {
                if (!cameraActive || video.readyState !== video.HAVE_ENOUGH_DATA) {
                    requestAnimationFrame(detectHand);
                    return;
                }
                
                // Draw video to hand canvas
                handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
                handCtx.save();
                handCtx.scale(-1, 1);
                handCtx.drawImage(video, -handCanvas.width, 0, handCanvas.width, handCanvas.height);
                handCtx.restore();
                
                // Get current frame data
                const frame = handCtx.getImageData(0, 0, handCanvas.width, handCanvas.height);
                
                // Detect hand using skin color and motion
                detectHandInFrame(frame);
                
                // Draw hand overlay
                drawHandOverlay();
                
                requestAnimationFrame(detectHand);
            }
            
            detectHand();
        }

        function detectHandInFrame(frame) {
            let skinPixels = 0;
            let totalX = 0;
            let totalY = 0;
            
            // Analyze every 4th pixel for performance
            for (let i = 0; i < frame.data.length; i += 16) {
                const r = frame.data[i];
                const g = frame.data[i + 1];
                const b = frame.data[i + 2];
                
                // Skin color detection (simplified)
                if (r > CONFIG.hand.skinColor.r.min && 
                    g > CONFIG.hand.skinColor.g.min && 
                    g < CONFIG.hand.skinColor.g.max && 
                    b < CONFIG.hand.skinColor.b.max &&
                    r > g && r > b) {
                    
                    skinPixels++;
                    const pixelIndex = i / 4;
                    totalX += pixelIndex % handCanvas.width;
                    totalY += Math.floor(pixelIndex / handCanvas.width);
                }
            }
            
            // If enough skin pixels detected, treat as hand
            if (skinPixels > CONFIG.hand.detectionThreshold) {
                isHandDetected = true;
                
                // Calculate hand center
                handPosition.x = 1 - (totalX / skinPixels) / handCanvas.width; // Mirror for display
                handPosition.y = (totalY / skinPixels) / handCanvas.height;
                
                // Calculate velocity
                handVelocity.x = (handPosition.x - lastHandPosition.x) * 20;
                handVelocity.y = (handPosition.y - lastHandPosition.y) * 20;
                
                lastHandPosition.x = handPosition.x;
                lastHandPosition.y = handPosition.y;
                
                // Detect gesture based on velocity
                detectHandGesture();
                
                // Update hand tracker
                updateHandTracker();
                
                updateStatus('Hand', 'DETECTED ‚úÖ');
                document.getElementById('handStatus').textContent = 'YES';
                document.getElementById('posX').textContent = handPosition.x.toFixed(2);
                document.getElementById('posY').textContent = handPosition.y.toFixed(2);
                
            } else {
                isHandDetected = false;
                updateStatus('Hand', 'NOT DETECTED');
                document.getElementById('handStatus').textContent = 'NO';
                document.getElementById('handTracker').style.display = 'none';
            }
        }

        function detectHandGesture() {
            const velocity = Math.sqrt(handVelocity.x * handVelocity.x + handVelocity.y * handVelocity.y);
            const now = Date.now();
            
            let newGesture = 'none';
            
            if (velocity < 0.3) {
                newGesture = 'fist';
            } else if (velocity > 2.0) {
                newGesture = 'palm';
            } else if (Math.abs(handVelocity.x) > Math.abs(handVelocity.y) * 1.5) {
                newGesture = 'swipe';
            } else {
                newGesture = 'open';
            }
            
            if (now - lastGestureTime > 300) {
                if (newGesture !== currentGesture) {
                    currentGesture = newGesture;
                    showGesturePopup();
                    lastGestureTime = now;
                }
            }
            
            document.getElementById('gestureType').textContent = currentGesture.toUpperCase();
        }

        function drawHandOverlay() {
            if (!isHandDetected) return;
            
            // Draw hand center
            const x = (1 - handPosition.x) * handCanvas.width; // Mirror back for drawing
            const y = handPosition.y * handCanvas.height;
            
            handCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            handCtx.beginPath();
            handCtx.arc(x, y, 40, 0, Math.PI * 2);
            handCtx.fill();
            
            // Draw hand point
            handCtx.fillStyle = '#ff0000';
            handCtx.beginPath();
            handCtx.arc(x, y, 10, 0, Math.PI * 2);
            handCtx.fill();
            
            // Draw velocity vector
            handCtx.strokeStyle = '#00ff00';
            handCtx.lineWidth = 3;
            handCtx.beginPath();
            handCtx.moveTo(x, y);
            handCtx.lineTo(x + handVelocity.x * 5, y + handVelocity.y * 5);
            handCtx.stroke();
            
            // Draw gesture text
            handCtx.fillStyle = '#ffffff';
            handCtx.font = 'bold 24px Arial';
            handCtx.textAlign = 'center';
            handCtx.fillText(currentGesture.toUpperCase(), x, y - 50);
        }

        function updateHandTracker() {
            const tracker = document.getElementById('handTracker');
            const screenX = handPosition.x * window.innerWidth;
            const screenY = handPosition.y * window.innerHeight;
            
            tracker.style.left = screenX + 'px';
            tracker.style.top = screenY + 'px';
            tracker.style.display = 'block';
            
            // Update emoji based on gesture
            const emojis = {
                'fist': '‚úä', 'palm': 'üñêÔ∏è', 'swipe': 'üí®', 'open': 'üëã'
            };
            document.querySelector('.tracker-emoji').textContent = emojis[currentGesture] || 'üëã';
            
            // Update color based on mode
            const colors = {
                'flow': '#00ffff', 'attract': '#ff0000', 'repel': '#00ff00',
                'swirl': '#ff00ff', 'rainbow': '#ffff00', 'explode': '#ff8800'
            };
            document.querySelector('.tracker-circle').style.borderColor = colors[currentMode] || '#00ffff';
            document.querySelector('.tracker-circle').style.boxShadow = `0 0 30px ${colors[currentMode] || '#00ffff'}`;
            
            // Update hand point
            const point = document.getElementById('handPoint');
            point.style.left = (screenX - 10) + 'px';
            point.style.top = (screenY - 10) + 'px';
            point.style.display = 'block';
            point.style.background = colors[currentMode] || '#ff0000';
            point.style.boxShadow = `0 0 20px ${colors[currentMode] || '#ff0000'}`;
        }

        // ========== MOUSE CONTROL FALLBACK ==========
        function setupMouseControl() {
            let mouseX = 0.5, mouseY = 0.5;
            let mouseDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX / window.innerWidth;
                mouseY = e.clientY / window.innerHeight;
                
                handPosition.x = mouseX;
                handPosition.y = mouseY;
                isHandDetected = true;
                currentGesture = mouseDown ? 'fist' : 'open';
                
                updateHandTracker();
                updateStatus('Hand', 'MOUSE CONTROL');
                document.getElementById('handStatus').textContent = 'MOUSE';
                document.getElementById('gestureType').textContent = currentGesture.toUpperCase();
                document.getElementById('posX').textContent = mouseX.toFixed(2);
                document.getElementById('posY').textContent = mouseY.toFixed(2);
            });
            
            document.addEventListener('mousedown', () => {
                mouseDown = true;
                currentGesture = 'fist';
                showGesturePopup();
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
                currentGesture = 'open';
                showGesturePopup();
            });
        }

        // ========== GESTURE EFFECTS ==========
        function showGesturePopup() {
            const popup = document.getElementById('gesturePopup');
            const emojis = {
                'fist': '‚úä', 'palm': 'üñêÔ∏è', 'swipe': 'üí®', 'open': 'üëã'
            };
            
            popup.textContent = emojis[currentGesture] || 'üëã';
            popup.style.opacity = '1';
            popup.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            setTimeout(() => {
                popup.style.opacity = '0';
                popup.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 500);
        }

        // ========== PARTICLE PHYSICS ==========
        function applyHandPhysics() {
            if (!isHandDetected || !particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            // Convert hand position to 3D space
            const handX3D = (handPosition.x - 0.5) * 40;
            const handY3D = -(handPosition.y - 0.5) * 30;
            
            // Update camera to follow hand
            camera.position.x += (handX3D - camera.position.x) * CONFIG.camera.smoothness;
            camera.position.y += (handY3D - camera.position.y) * CONFIG.camera.smoothness;
            camera.lookAt(handX3D * 0.7, handY3D * 0.7, 0);
            
            // Update point light to follow hand
            if (window.pointLight) {
                window.pointLight.position.set(handX3D, handY3D, 10);
                
                // Change light color based on gesture
                const lightColors = {
                    'fist': 0xff0000, 'palm': 0x00ff00, 'swipe': 0x0000ff, 'open': 0x00ffff
                };
                window.pointLight.color.setHex(lightColors[currentGesture] || 0x00ffff);
                window.pointLight.intensity = 1.5 + Math.sin(time * 2) * 0.5;
            }
            
            // Apply particle effects based on mode and gesture
            const power = CONFIG.particles.power;
            
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // Calculate distance to hand
                const dx = handX3D - p.x;
                const dy = handY3D - p.y;
                const dz = -p.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) + 1;
                
                // Apply mode-specific forces
                switch(currentMode) {
                    case 'attract':
                        // Attract particles to hand
                        const attractForce = CONFIG.particles.attraction * power / distance;
                        p.vx += dx * attractForce;
                        p.vy += dy * attractForce;
                        p.vz += dz * attractForce;
                        break;
                        
                    case 'repel':
                        // Repel particles from hand
                        const repelForce = CONFIG.particles.repulsion * power / (distance * distance);
                        p.vx -= dx * repelForce;
                        p.vy -= dy * repelForce;
                        p.vz -= dz * repelForce;
                        break;
                        
                    case 'swirl':
                        // Swirl around hand
                        const swirlForce = 0.04 * power;
                        const angle = Math.atan2(dy, dx);
                        p.vx += Math.cos(angle + Math.PI/2) * swirlForce;
                        p.vy += Math.sin(angle + Math.PI/2) * swirlForce;
                        break;
                        
                    case 'rainbow':
                        // Color cycling
                        const hue = (time * 0.5 + i * 0.001) % 1;
                        p.color.setHSL(hue, 0.9, 0.5);
                        colors[i * 3] = p.color.r;
                        colors[i * 3 + 1] = p.color.g;
                        colors[i * 3 + 2] = p.color.b;
                        break;
                        
                    case 'explode':
                        // Explosion from hand
                        if (distance < 15) {
                            const explodeForce = 0.1 * power;
                            p.vx += dx * explodeForce;
                            p.vy += dy * explodeForce;
                            p.vz += (Math.random() - 0.5) * 2;
                        }
                        break;
                        
                    case 'flow':
                    default:
                        // Gentle flow following hand movement
                        const flowForce = 0.01 * power / distance;
                        p.vx += handVelocity.x * flowForce;
                        p.vy += -handVelocity.y * flowForce;
                        break;
                }
                
                // Natural movement based on original position
                const returnForce = 0.005 * power;
                p.vx += (p.originalX - p.x) * returnForce;
                p.vy += (p.originalY - p.y) * returnForce;
                p.vz += (p.originalZ - p.z) * returnForce;
                
                // Apply velocity
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                // Apply friction
                p.vx *= CONFIG.particles.friction;
                p.vy *= CONFIG.particles.friction;
                p.vz *= CONFIG.particles.friction;
                
                // Update position in buffer
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            }
            
            // Mark buffers for update
            particleSystem.geometry.attributes.position.needsUpdate = true;
            if (currentMode === 'rainbow') {
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }
        }

        // ========== UI CONTROLS ==========
        function setupUIControls() {
            // Particle count slider
            document.getElementById('particleSlider').addEventListener('input', (e) => {
                CONFIG.particles.count = parseInt(e.target.value);
                document.getElementById('particleValue').textContent = CONFIG.particles.count.toLocaleString();
                createParticleSystem();
            });
            
            // Power slider
            document.getElementById('powerSlider').addEventListener('input', (e) => {
                CONFIG.particles.power = parseFloat(e.target.value);
                document.getElementById('powerValue').textContent = CONFIG.particles.power.toFixed(1);
            });
            
            // Size slider
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                CONFIG.particles.size = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = CONFIG.particles.size.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = CONFIG.particles.size;
                    const sizes = particleSystem.geometry.attributes.size.array;
                    for (let i = 0; i < particles.length; i++) {
                        sizes[i] = particles[i].size * CONFIG.particles.size;
                    }
                    particleSystem.geometry.attributes.size.needsUpdate = true;
                }
            });
            
            // Mode buttons
            window.setMode = function(mode) {
                currentMode = mode;
                
                // Update active button
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                // Show mode change effect
                const popup = document.getElementById('gesturePopup');
                const emojis = {
                    'flow': 'üåÄ', 'attract': '‚úä', 'repel': 'üñêÔ∏è',
                    'swirl': 'üå™Ô∏è', 'rainbow': 'üåà', 'explode': 'üí•'
                };
                
                popup.textContent = emojis[mode] || 'üåÄ';
                popup.style.opacity = '1';
                popup.style.transform = 'translate(-50%, -50%) scale(1.5)';
                
                setTimeout(() => {
                    popup.style.opacity = '0';
                    popup.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 800);
            };
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                const modes = {
                    '1': 'flow', '2': 'attract', '3': 'repel',
                    '4': 'swirl', '5': 'rainbow', '6': 'explode'
                };
                
                if (modes[key]) {
                    setMode(modes[key]);
                    
                    // Update active button
                    const buttons = document.querySelectorAll('.mode-btn');
                    buttons.forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.textContent.includes(modes[key].toUpperCase())) {
                            btn.classList.add('active');
                        }
                    });
                }
                
                // Space for rainbow effect
                if (e.key === ' ') {
                    currentMode = 'rainbow';
                    setMode('rainbow');
                }
            });
        }

        // ========== UTILITY FUNCTIONS ==========
        function updateStatus(type, value) {
            if (type === 'Camera') {
                document.getElementById('cameraStatus').textContent = value;
            } else if (type === 'Hand') {
                // Status already updated in other functions
            }
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            
            if (now >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016 * CONFIG.particles.power;
            updateFPS();
            
            // Apply hand physics
            applyHandPhysics();
            
            // Update particles
            if (particleSystem) {
                // Gentle rotation
                particleSystem.rotation.y += 0.001 * CONFIG.particles.power;
                particleSystem.rotation.x += 0.0005 * CONFIG.particles.power;
                
                // Particle breathing effect
                const sizes = particleSystem.geometry.attributes.size.array;
                for (let i = 0; i < particles.length; i++) {
                    const pulse = Math.sin(time + particles[i].phase) * 0.2 + 0.8;
                    sizes[i] = particles[i].size * CONFIG.particles.size * pulse;
                }
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== INITIALIZE EVERYTHING ==========
        async function init() {
            try {
                console.log("üöÄ Starting Live Hand Control...");
                initThreeJS();
                setupUIControls();
                await initWebcam();
                animate();
                
                console.log("‚úÖ System ready!");
                console.log("üëã Show your hand to the camera");
                console.log("üéÆ Use hand gestures to control particles");
                console.log("üîë Press 1-6 to change modes");
                
            } catch (error) {
                console.error("‚ùå Error:", error);
            }
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
