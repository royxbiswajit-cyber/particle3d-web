<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BR Earth System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* Professional Minimal Branding */
        .brand {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .brand-name {
            font-size: 22px;
            font-weight: 300;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }
        
        .brand-subtitle {
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 3px;
            opacity: 0.6;
            text-transform: uppercase;
        }
        
        /* Hand Status Indicator */
        .hand-status {
            position: absolute;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .hand-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }
        
        .hand-dot.active {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }
        
        .hand-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 400;
        }
        
        /* Camera Feed (Hidden but functional) */
        .camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.3;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .camera-feed video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        /* Instructions (Fades out after 10 seconds) */
        .instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            max-width: 400px;
            animation: fadeOut 10s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    
    <!-- Professional Branding -->
    <div class="brand">
        <div class="brand-name">BISWAJIT ROY</div>
        <div class="brand-subtitle">EARTH CONTROL SYSTEM</div>
    </div>
    
    <!-- Hand Status -->
    <div class="hand-status">
        <div class="hand-dot" id="handDot"></div>
        <div class="hand-text" id="handText">INITIALIZING...</div>
    </div>
    
    <!-- Camera Feed -->
    <div class="camera-feed">
        <video id="cameraVideo" autoplay playsinline muted></video>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        Move hand in front of camera to control Earth ‚Ä¢ ‚úä Fist = Zoom ‚Ä¢ üñêÔ∏è Open = Rotate ‚Ä¢ ‚úåÔ∏è Two Fingers = Change View
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ========== PROFESSIONAL EARTH CONTROL SYSTEM ==========
        console.log("üöÄ BISWAJIT ROY - Professional Earth Control System v3.0");
        
        // ========== CONFIGURATION ==========
        const CONFIG = {
            // Earth Settings
            EARTH_RADIUS: 5,
            EARTH_SEGMENTS: 128,
            ROTATION_SPEED: 0.002,
            AUTO_ROTATION: true,
            
            // Camera Settings
            CAMERA_DISTANCE: 20,
            CAMERA_MIN_DISTANCE: 10,
            CAMERA_MAX_DISTANCE: 40,
            CAMERA_SMOOTHNESS: 0.1,
            
            // Hand Control
            HAND_SMOOTHING: 0.2,
            ROTATION_SENSITIVITY: 2.5,
            ZOOM_SENSITIVITY: 0.8,
            ZOOM_SPEED: 0.05,
            
            // Physics
            INERTIA_DECAY: 0.95,
            FRICTION: 0.92,
            BOUNCE_DAMPING: 0.8
        };

        // ========== GLOBAL STATE ==========
        let scene, camera, renderer;
        let earth, clouds, atmosphere;
        let earthGroup;
        let stars = [];
        
        // Hand State
        let hand = {
            detected: false,
            position: { x: 0.5, y: 0.5 },
            smooth: { x: 0.5, y: 0.5 },
            lastPos: { x: 0.5, y: 0.5 },
            velocity: { x: 0, y: 0 },
            gestures: {
                open: false,
                fist: false,
                pinch: false,
                twoFingers: false,
                thumbUp: false,
                palmSize: 0
            },
            lastGesture: null,
            zoomLevel: 1.0,
            rotationInertia: { x: 0, y: 0 },
            zoomInertia: 0,
            lastPinchDistance: 0.1
        };
        
        // Camera State
        let cameraState = {
            distance: CONFIG.CAMERA_DISTANCE,
            targetDistance: CONFIG.CAMERA_DISTANCE,
            rotation: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 }
        };
        
        // System State
        let video;
        let handResults = null;
        let clock = new THREE.Clock();
        let earthTextures = {};
        let currentView = 'day';
        let isInitialized = false;

        // ========== INITIALIZE THREE.JS ==========
        async function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 50, 200);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.CAMERA_DISTANCE;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Load Earth textures
            await loadEarthTextures();
            
            // Create realistic Earth
            createRealisticEarth();
            
            // Create stars background
            createStarField();
            
            // Setup advanced lighting
            setupAdvancedLighting();
            
            console.log("‚úÖ Three.js initialized with realistic Earth");
        }

        // ========== LOAD EARTH TEXTURES ==========
        async function loadEarthTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // NASA-quality Earth textures
            earthTextures.day = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
            earthTextures.night = textureLoader.load('https://threejs.org/examples/textures/planets/earth_night_2048.jpg');
            earthTextures.specular = textureLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg');
            earthTextures.normal = textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg');
            earthTextures.clouds = textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');
            
            // Set texture parameters for quality
            Object.values(earthTextures).forEach(texture => {
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            });
            
            console.log("‚úÖ Earth textures loaded");
        }

        // ========== CREATE REALISTIC EARTH ==========
        function createRealisticEarth() {
            earthGroup = new THREE.Group();
            scene.add(earthGroup);
            
            // Earth sphere (high detail)
            const earthGeometry = new THREE.SphereGeometry(
                CONFIG.EARTH_RADIUS, 
                CONFIG.EARTH_SEGMENTS, 
                CONFIG.EARTH_SEGMENTS
            );
            
            // Realistic Earth material
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthTextures.day,
                specularMap: earthTextures.specular,
                specular: new THREE.Color(0x333333),
                shininess: 5,
                normalMap: earthTextures.normal,
                normalScale: new THREE.Vector2(0.5, 0.5),
                transparent: true,
                opacity: 1.0
            });
            
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.castShadow = true;
            earth.receiveShadow = true;
            earthGroup.add(earth);
            
            // Clouds layer (slightly larger and rotating differently)
            const cloudGeometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS * 1.005, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: earthTextures.clouds,
                transparent: true,
                opacity: 0.4,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            clouds.rotation.x = -0.2;
            earthGroup.add(clouds);
            
            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS * 1.1, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0x0099ff) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vView;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vView = normalize(-mvPosition.xyz);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying vec3 vNormal;
                    varying vec3 vView;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vView), 2.0);
                        gl_FragColor = vec4(glowColor, intensity * 0.3);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthGroup.add(atmosphere);
            
            // Initial rotation
            earthGroup.rotation.x = -0.3;
            earthGroup.rotation.y = 2.5;
            
            console.log("‚úÖ Realistic Earth created");
        }

        // ========== CREATE STAR FIELD ==========
        function createStarField() {
            const starCount = 2000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Random position in a sphere
                const radius = 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i3 + 2] = radius * Math.cos(phi);
                
                // Random star colors (mostly white/blue)
                starColors[i3] = 0.8 + Math.random() * 0.2;
                starColors[i3 + 1] = 0.8 + Math.random() * 0.2;
                starColors[i3 + 2] = 0.9 + Math.random() * 0.1;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        // ========== SETUP ADVANCED LIGHTING ==========
        function setupAdvancedLighting() {
            // Sun (directional light)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(100, 50, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            // Hemisphere light for ambient
            const hemiLight = new THREE.HemisphereLight(0x4488ff, 0x002244, 0.3);
            scene.add(hemiLight);
            
            // Point light for Earth glow
            const earthGlow = new THREE.PointLight(0x0099ff, 0.5, 50);
            earthGlow.position.copy(earth.position);
            scene.add(earthGlow);
        }

        // ========== INITIALIZE CAMERA ==========
        async function initCamera() {
            video = document.getElementById('cameraVideo');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "user",
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                await video.play();
                
                // Start hand tracking
                startHandTracking();
                
                updateHandStatus(true, "CAMERA ACTIVE");
                return true;
            } catch (error) {
                console.error("Camera error:", error);
                updateHandStatus(false, "CAMERA ERROR");
                return false;
            }
        }

        // ========== START HAND TRACKING ==========
        function startHandTracking() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults((results) => {
                handResults = results;
                processHandResults(results);
            });
            
            const camera = new Camera(video, {
                onFrame: async () => {
                    try {
                        await hands.send({image: video});
                    } catch (e) {
                        console.warn("Hand tracking frame skipped");
                    }
                },
                width: 640,
                height: 480
            });
            
            camera.start();
            console.log("‚úÖ Hand tracking started");
        }

        // ========== PROCESS HAND RESULTS ==========
        function processHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                hand.detected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Get palm center (average of palm landmarks)
                const palmLandmarks = [landmarks[0], landmarks[1], landmarks[5], landmarks[9], landmarks[13], landmarks[17]];
                let sumX = 0, sumY = 0;
                palmLandmarks.forEach(lm => {
                    sumX += lm.x;
                    sumY += lm.y;
                });
                
                hand.position.x = sumX / palmLandmarks.length;
                hand.position.y = sumY / palmLandmarks.length;
                
                // Calculate velocity
                hand.velocity.x = hand.position.x - hand.lastPos.x;
                hand.velocity.y = hand.position.y - hand.lastPos.y;
                hand.lastPos.x = hand.position.x;
                hand.lastPos.y = hand.position.y;
                
                // Smooth position
                hand.smooth.x += (hand.position.x - hand.smooth.x) * CONFIG.HAND_SMOOTHING;
                hand.smooth.y += (hand.position.y - hand.smooth.y) * CONFIG.HAND_SMOOTHING;
                
                // Detect gestures
                detectGestures(landmarks);
                
                updateHandStatus(true, "HAND DETECTED");
            } else {
                hand.detected = false;
                hand.velocity.x = hand.velocity.y = 0;
                updateHandStatus(false, "NO HAND");
            }
        }

        // ========== DETECT GESTURES ==========
        function detectGestures(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // Calculate distances
            const thumbIndexDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const indexMiddleDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
            
            // Detect palm size (for zoom)
            let maxDist = 0;
            for (let i = 0; i < landmarks.length; i++) {
                for (let j = i + 1; j < landmarks.length; j++) {
                    const dist = Math.hypot(landmarks[i].x - landmarks[j].x, landmarks[i].y - landmarks[j].y);
                    if (dist > maxDist) maxDist = dist;
                }
            }
            hand.gestures.palmSize = maxDist;
            
            // Gesture: Fist (all fingers close to wrist)
            let fingersClose = true;
            for (let i = 8; i <= 20; i += 4) {
                const dist = Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y);
                if (dist > 0.2) {
                    fingersClose = false;
                    break;
                }
            }
            hand.gestures.fist = fingersClose;
            
            // Gesture: Open hand (not fist and fingers spread)
            hand.gestures.open = !fingersClose && thumbIndexDist > 0.15;
            
            // Gesture: Pinch (thumb and index close)
            hand.gestures.pinch = thumbIndexDist < 0.05;
            
            // Gesture: Two fingers (peace sign)
            hand.gestures.twoFingers = (
                thumbIndexDist < 0.08 && 
                indexMiddleDist > 0.12 && 
                !fingersClose
            );
            
            // Gesture: Thumb up (thumb extended, others closed)
            const thumbDist = Math.hypot(thumbTip.x - wrist.x, thumbTip.y - wrist.y);
            const otherFingersClose = 
                Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y) < 0.15 &&
                Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y) < 0.15 &&
                Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y) < 0.15 &&
                Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y) < 0.15;
            
            hand.gestures.thumbUp = thumbDist > 0.2 && otherFingersClose;
        }

        // ========== UPDATE HAND STATUS ==========
        function updateHandStatus(detected, text) {
            const dot = document.getElementById('handDot');
            const textEl = document.getElementById('handText');
            
            if (detected) {
                dot.className = 'hand-dot active';
                textEl.textContent = text;
            } else {
                dot.className = 'hand-dot';
                textEl.textContent = text;
            }
        }

        // ========== UPDATE EARTH CONTROL ==========
        function updateEarthControl(deltaTime) {
            if (!hand.detected) {
                // Apply inertia decay when no hand
                hand.rotationInertia.x *= CONFIG.INERTIA_DECAY;
                hand.rotationInertia.y *= CONFIG.INERTIA_DECAY;
                hand.zoomInertia *= CONFIG.INERTIA_DECAY;
                
                // Auto-rotate when no interaction
                if (CONFIG.AUTO_ROTATION) {
                    earthGroup.rotation.y += CONFIG.ROTATION_SPEED;
                }
                
                return;
            }
            
            // Calculate normalized hand movement
            const moveX = (hand.smooth.x - 0.5) * 2;
            const moveY = (hand.smooth.y - 0.5) * 2;
            
            // ROTATION CONTROL (with hand movement)
            if (hand.gestures.open) {
                const rotationX = moveY * CONFIG.ROTATION_SENSITIVITY * deltaTime;
                const rotationY = -moveX * CONFIG.ROTATION_SENSITIVITY * deltaTime;
                
                // Add to inertia
                hand.rotationInertia.x += rotationX;
                hand.rotationInertia.y += rotationY;
            }
            
            // ZOOM CONTROL (with fist/palm size)
            if (hand.gestures.fist) {
                // Zoom out when fist
                hand.zoomInertia -= CONFIG.ZOOM_SENSITIVITY * deltaTime;
            } else if (hand.gestures.open) {
                // Zoom in based on palm size
                const zoomAmount = (hand.gestures.palmSize - 0.2) * CONFIG.ZOOM_SPEED * deltaTime;
                hand.zoomInertia += zoomAmount;
            }
            
            // PINCH ZOOM
            if (hand.gestures.pinch) {
                const currentPinch = hand.gestures.palmSize;
                const pinchDelta = currentPinch - hand.lastPinchDistance;
                hand.zoomInertia += pinchDelta * 5;
                hand.lastPinchDistance = currentPinch;
            } else {
                hand.lastPinchDistance = hand.gestures.palmSize;
            }
            
            // VIEW CHANGE (two fingers)
            if (hand.gestures.twoFingers && !hand.gestures.lastTwoFingers) {
                currentView = currentView === 'day' ? 'night' : 'day';
                earth.material.map = earthTextures[currentView];
                earth.material.needsUpdate = true;
            }
            hand.gestures.lastTwoFingers = hand.gestures.twoFingers;
            
            // RESET (thumb up)
            if (hand.gestures.thumbUp && !hand.lastThumbUp) {
                // Reset camera and rotation
                cameraState.targetDistance = CONFIG.CAMERA_DISTANCE;
                cameraState.targetRotation.x = 0;
                cameraState.targetRotation.y = 0;
                hand.rotationInertia.x = 0;
                hand.rotationInertia.y = 0;
                hand.zoomInertia = 0;
            }
            hand.lastThumbUp = hand.gestures.thumbUp;
            
            // Apply rotation inertia to Earth
            earthGroup.rotation.x += hand.rotationInertia.x;
            earthGroup.rotation.y += hand.rotationInertia.y;
            
            // Apply friction to rotation inertia
            hand.rotationInertia.x *= CONFIG.FRICTION;
            hand.rotationInertia.y *= CONFIG.FRICTION;
            
            // Apply zoom inertia to camera
            cameraState.targetDistance += hand.zoomInertia;
            cameraState.targetDistance = Math.max(
                CONFIG.CAMERA_MIN_DISTANCE,
                Math.min(CONFIG.CAMERA_MAX_DISTANCE, cameraState.targetDistance)
            );
            
            // Apply friction to zoom inertia
            hand.zoomInertia *= CONFIG.FRICTION;
            
            // Smooth camera movement
            cameraState.distance += (cameraState.targetDistance - cameraState.distance) * CONFIG.CAMERA_SMOOTHNESS;
            camera.position.z = cameraState.distance;
            
            // Update cloud rotation (slightly different speed)
            clouds.rotation.y += deltaTime * 0.001;
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            
            // Update Earth control
            updateEarthControl(deltaTime);
            
            // Update camera to look at Earth
            camera.lookAt(0, 0, 0);
            
            // Update atmosphere shader
            if (atmosphere.material.uniforms) {
                atmosphere.material.uniforms.viewVector.value = camera.position;
            }
            
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE ==========
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========== INITIALIZE SYSTEM ==========
        async function init() {
            console.log("üöÄ Initializing Professional Earth Control System...");
            
            // Initialize Three.js
            await initThreeJS();
            
            // Initialize Camera
            await initCamera();
            
            // Start animation loop
            animate();
            
            // Add event listeners
            window.addEventListener('resize', onResize);
            
            // Mark as initialized
            isInitialized = true;
            console.log("‚úÖ System fully initialized and ready");
        }

        // ========== START EVERYTHING ==========
        init();
    </script>
</body>
</html>
