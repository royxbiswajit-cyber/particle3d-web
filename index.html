<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Biswajit Roy - Earth Hologram</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas { 
            display: block; 
        }
        
        /* Branding Styles */
        .brand-container {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            text-align: center;
            pointer-events: none;
        }
        
        .brand-name {
            color: #00ff88;
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-shadow: 0 0 30px #00ff88;
        }
        
        .brand-title {
            color: #88ffff;
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 4px;
            opacity: 0.8;
        }
        
        /* Data Panel */
        .data-panel {
            position: absolute;
            top: 120px;
            left: 30px;
            z-index: 1000;
            background: rgba(0, 20, 40, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        .panel-title {
            color: #00ffff;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .data-label {
            color: #88ffff;
            font-size: 14px;
        }
        
        .data-value {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff88;
        }
        
        /* Network Grid */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.15;
        }
        
        /* Control Panel */
        .control-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: flex;
            gap: 15px;
        }
        
        .control-btn {
            background: rgba(0, 40, 80, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 50px;
            padding: 12px 25px;
            color: #00ffff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(0, 80, 120, 0.7);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }
        
        /* FPS Counter */
        .fps-counter {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #00ff88;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #00ff88;
        }
        
        /* Scan Lines */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 255, 255, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
            opacity: 0.3;
        }
        
        /* Digital Pulse */
        .pulse-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Visual Effects -->
    <div class="scanlines"></div>
    <div class="grid-overlay" id="gridOverlay"></div>
    <div class="pulse-effect" id="pulseEffect"></div>
    
    <!-- Branding -->
    <div class="brand-container">
        <div class="brand-name">Biswajit Roy</div>
        <div class="brand-title">EARTH HOLOGRAM SYSTEM</div>
    </div>
    
    <!-- Data Panel -->
    <div class="data-panel">
        <div class="panel-title">
            <span>üåç SYSTEM STATUS</span>
        </div>
        
        <div class="data-row">
            <span class="data-label">HOLOGRAM INTEGRITY</span>
            <span class="data-value" id="integrity">100%</span>
        </div>
        
        <div class="data-row">
            <span class="data-label">NETWORK NODES</span>
            <span class="data-value" id="nodes">2,847</span>
        </div>
        
        <div class="data-row">
            <span class="data-label">DATA FLOW</span>
            <span class="data-value" id="dataFlow">4.7 TB/s</span>
        </div>
        
        <div class="data-row">
            <span class="data-label">ENERGY OUTPUT</span>
            <span class="data-value" id="energy">98.3%</span>
        </div>
        
        <div class="data-row">
            <span class="data-label">ROTATION SPEED</span>
            <span class="data-value" id="rotation">1.0x</span>
        </div>
    </div>
    
    <!-- Control Panel -->
    <div class="control-panel">
        <button class="control-btn" onclick="toggleRotation()">
            <span>üîÑ</span> ROTATION
        </button>
        <button class="control-btn" onclick="toggleNetwork()">
            <span>üåê</span> NETWORK
        </button>
        <button class="control-btn" onclick="pulseEffect()">
            <span>‚ö°</span> PULSE
        </button>
    </div>
    
    <!-- FPS Counter -->
    <div class="fps-counter">FPS: <span id="fpsValue">60</span></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== BISWAJIT ROY EARTH HOLOGRAM SYSTEM ==========
        const BRSYSTEM = {
            version: "2.0",
            author: "Biswajit Roy",
            created: "EARTH HOLOGRAM v2.0"
        };

        console.log(`üåç ${BRSYSTEM.author} - ${BRSYSTEM.created}`);

        // ========== CONFIGURATION ==========
        const CONFIG = {
            EARTH_RADIUS: 10,
            ATMOSPHERE_RADIUS: 10.5,
            GRID_SIZE: 50,
            GRID_DIVISIONS: 100,
            DATA_NODES: 500,
            PULSE_SPEED: 0.5,
            ROTATION_SPEED: 0.002,
            GLOW_INTENSITY: 1.5,
            NETWORK_ACTIVE: true
        };

        // ========== STATE ==========
        let scene, camera, renderer;
        let earth, atmosphere, dataNodes = [];
        let networkLines = [];
        let pulseWave = null;
        let rotationActive = true;
        let networkActive = true;
        let clock = new THREE.Clock();
        let fps = 60;
        let lastFpsUpdate = 0;
        let frameCount = 0;

        // ========== INIT THREE.JS ==========
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a1a, 50, 200);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 35);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x0a0a0f);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Create Earth Hologram
            createEarthHologram();
            
            // Create Digital Network
            createDigitalNetwork();
            
            // Create Data Nodes
            createDataNodes();
            
            // Setup Lighting
            setupFuturisticLighting();
            
            // Create Network Grid Overlay
            createGridOverlay();
            
            // Initial pulse
            setTimeout(() => pulseEffect(), 1000);
        }

        // ========== CREATE EARTH HOLOGRAM ==========
        function createEarthHologram() {
            // Earth Sphere
            const earthGeometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS, 64, 64);
            
            // Create custom green holographic material
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff88,
                emissive: 0x00aa55,
                emissiveIntensity: CONFIG.GLOW_INTENSITY,
                transparent: true,
                opacity: 0.9,
                shininess: 100,
                specular: 0x00ff88
            });
            
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.castShadow = true;
            earth.receiveShadow = true;
            scene.add(earth);
            
            // Atmosphere Glow
            const atmosphereGeometry = new THREE.SphereGeometry(CONFIG.ATMOSPHERE_RADIUS, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            
            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
            
            // Continent Lines (simulated)
            createContinentLines();
            
            // Orbital Ring
            createOrbitalRing();
        }

        // ========== CREATE CONTINENT LINES ==========
        function createContinentLines() {
            const linesMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.6
            });
            
            // Create 8 longitudinal lines
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const points = [];
                
                for (let j = 0; j <= 32; j++) {
                    const lat = (j / 32) * Math.PI;
                    const x = CONFIG.EARTH_RADIUS * Math.sin(lat) * Math.cos(angle);
                    const y = CONFIG.EARTH_RADIUS * Math.cos(lat);
                    const z = CONFIG.EARTH_RADIUS * Math.sin(lat) * Math.sin(angle);
                    
                    // Add some variation
                    const variation = 0.98 + Math.sin(lat * 8) * 0.02;
                    points.push(new THREE.Vector3(x * variation, y * variation, z * variation));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, linesMaterial);
                earth.add(line);
            }
            
            // Create latitudinal rings
            for (let i = 1; i < 5; i++) {
                const lat = (i / 5) * Math.PI;
                const points = [];
                
                for (let j = 0; j <= 64; j++) {
                    const lon = (j / 64) * Math.PI * 2;
                    const x = CONFIG.EARTH_RADIUS * Math.sin(lat) * Math.cos(lon);
                    const y = CONFIG.EARTH_RADIUS * Math.cos(lat);
                    const z = CONFIG.EARTH_RADIUS * Math.sin(lat) * Math.sin(lon);
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, linesMaterial);
                earth.add(line);
            }
        }

        // ========== CREATE ORBITAL RING ==========
        function createOrbitalRing() {
            const ringGeometry = new THREE.RingGeometry(CONFIG.EARTH_RADIUS + 3, CONFIG.EARTH_RADIUS + 3.2, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);
            
            // Pulsing dots on ring
            const dotGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const dotMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true
            });
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                
                dot.position.x = Math.cos(angle) * (CONFIG.EARTH_RADIUS + 3);
                dot.position.z = Math.sin(angle) * (CONFIG.EARTH_RADIUS + 3);
                dot.userData = {
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 1
                };
                
                scene.add(dot);
                dataNodes.push(dot);
            }
        }

        // ========== CREATE DIGITAL NETWORK ==========
        function createDigitalNetwork() {
            // Create grid floor
            const gridGeometry = new THREE.PlaneGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_DIVISIONS, CONFIG.GRID_DIVISIONS);
            const gridMaterial = new THREE.MeshBasicMaterial({
                color: 0x0088ff,
                wireframe: true,
                transparent: true,
                opacity: 0.1
            });
            
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = -CONFIG.EARTH_RADIUS - 5;
            scene.add(grid);
            
            // Create vertical grid lines
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.05
            });
            
            for (let i = -CONFIG.GRID_SIZE/2; i <= CONFIG.GRID_SIZE/2; i += 5) {
                // X-direction lines
                const points1 = [
                    new THREE.Vector3(i, -CONFIG.EARTH_RADIUS - 5, -CONFIG.GRID_SIZE/2),
                    new THREE.Vector3(i, -CONFIG.EARTH_RADIUS - 5, CONFIG.GRID_SIZE/2),
                    new THREE.Vector3(i, CONFIG.EARTH_RADIUS + 10, CONFIG.GRID_SIZE/2)
                ];
                
                const line1 = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints(points1),
                    lineMaterial
                );
                scene.add(line1);
                networkLines.push(line1);
                
                // Z-direction lines
                const points2 = [
                    new THREE.Vector3(-CONFIG.GRID_SIZE/2, -CONFIG.EARTH_RADIUS - 5, i),
                    new THREE.Vector3(CONFIG.GRID_SIZE/2, -CONFIG.EARTH_RADIUS - 5, i),
                    new THREE.Vector3(CONFIG.GRID_SIZE/2, CONFIG.EARTH_RADIUS + 10, i)
                ];
                
                const line2 = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints(points2),
                    lineMaterial
                );
                scene.add(line2);
                networkLines.push(line2);
            }
        }

        // ========== CREATE DATA NODES ==========
        function createDataNodes() {
            const nodeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const nodeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true
            });
            
            for (let i = 0; i < CONFIG.DATA_NODES; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.EARTH_RADIUS + 5 + Math.random() * 10;
                const height = (Math.random() - 0.5) * 20;
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                
                node.position.x = Math.cos(angle) * radius;
                node.position.y = height;
                node.position.z = Math.sin(angle) * radius;
                
                node.userData = {
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.3 + Math.random() * 0.7,
                    radius: radius,
                    angle: angle,
                    pulse: 0
                };
                
                scene.add(node);
                dataNodes.push(node);
            }
        }

        // ========== SETUP FUTURISTIC LIGHTING ==========
        function setupFuturisticLighting() {
            // Main green light
            const mainLight = new THREE.PointLight(0x00ff88, 1.5, 100);
            mainLight.position.set(0, 10, 20);
            scene.add(mainLight);
            
            // Blue accent lights
            const accentLight1 = new THREE.PointLight(0x0088ff, 0.8, 50);
            accentLight1.position.set(20, 10, 0);
            scene.add(accentLight1);
            
            const accentLight2 = new THREE.PointLight(0x0088ff, 0.8, 50);
            accentLight2.position.set(-20, 10, 0);
            scene.add(accentLight2);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x004488, 0.2);
            scene.add(ambientLight);
            
            // Earth glow effect
            const earthGlow = new THREE.PointLight(0x00ff88, 2, CONFIG.ATMOSPHERE_RADIUS * 3);
            earthGlow.position.set(0, 0, 0);
            scene.add(earthGlow);
        }

        // ========== CREATE GRID OVERLAY ==========
        function createGridOverlay() {
            const gridOverlay = document.getElementById('gridOverlay');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Draw digital grid pattern
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw diagonal lines
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.02)';
            const diagonalSpacing = 100;
            
            for (let i = -canvas.height; i < canvas.width; i += diagonalSpacing) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i + canvas.height, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(i + canvas.height, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            gridOverlay.style.backgroundImage = `url(${canvas.toDataURL()})`;
        }

        // ========== UPDATE DATA PANEL ==========
        function updateDataPanel(time) {
            const integrity = document.getElementById('integrity');
            const nodes = document.getElementById('nodes');
            const dataFlow = document.getElementById('dataFlow');
            const energy = document.getElementById('energy');
            const rotation = document.getElementById('rotation');
            
            // Animate values
            const pulse = Math.sin(time * 0.001) * 0.5 + 0.5;
            
            integrity.textContent = `${(95 + pulse * 5).toFixed(1)}%`;
            nodes.textContent = `${(CONFIG.DATA_NODES + Math.sin(time * 0.0003) * 100).toFixed(0)}`;
            dataFlow.textContent = `${(4.5 + pulse * 0.4).toFixed(1)} TB/s`;
            energy.textContent = `${(97 + pulse * 2).toFixed(1)}%`;
            rotation.textContent = `${(rotationActive ? 1.0 : 0.0).toFixed(1)}x`;
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = clock.getDelta();
            
            // Update FPS
            updateFPS(time);
            
            // Rotate Earth
            if (rotationActive) {
                earth.rotation.y += CONFIG.ROTATION_SPEED;
                atmosphere.rotation.y += CONFIG.ROTATION_SPEED * 0.5;
            }
            
            // Animate data nodes
            dataNodes.forEach((node, index) => {
                if (node.userData.radius) {
                    // Orbital motion
                    node.userData.angle += node.userData.speed * 0.01;
                    node.position.x = Math.cos(node.userData.angle) * node.userData.radius;
                    node.position.z = Math.sin(node.userData.angle) * node.userData.radius;
                    
                    // Pulsing effect
                    node.userData.phase += 0.05;
                    const scale = 1 + Math.sin(node.userData.phase) * 0.3;
                    node.scale.setScalar(scale);
                    
                    // Glow effect
                    node.material.opacity = 0.3 + Math.sin(node.userData.phase) * 0.3;
                    node.material.color.setHSL(0.5 + Math.sin(time * 0.001 + index * 0.1) * 0.1, 1, 0.5);
                }
            });
            
            // Update atmosphere glow
            const glowIntensity = 0.8 + Math.sin(time * 0.001) * 0.2;
            earth.material.emissiveIntensity = CONFIG.GLOW_INTENSITY * glowIntensity;
            atmosphere.material.opacity = 0.1 + Math.sin(time * 0.0005) * 0.05;
            
            // Animate network lines
            if (networkActive) {
                networkLines.forEach((line, index) => {
                    const opacity = 0.05 + Math.sin(time * 0.001 + index) * 0.03;
                    line.material.opacity = Math.max(0.02, opacity);
                });
            }
            
            // Update camera position with subtle movement
            camera.position.x = Math.sin(time * 0.0002) * 2;
            camera.position.y = 5 + Math.sin(time * 0.0003) * 0.5;
            camera.lookAt(0, 0, 0);
            
            // Update data panel
            updateDataPanel(time);
            
            renderer.render(scene, camera);
        }

        // ========== UPDATE FPS ==========
        function updateFPS(time) {
            frameCount++;
            
            if (time >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (time - lastFpsUpdate));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = time;
            }
        }

        // ========== CONTROL FUNCTIONS ==========
        function toggleRotation() {
            rotationActive = !rotationActive;
            document.querySelector('.control-btn:nth-child(1)').style.background = 
                rotationActive ? 'rgba(0, 80, 120, 0.7)' : 'rgba(80, 0, 0, 0.7)';
        }
        
        function toggleNetwork() {
            networkActive = !networkActive;
            networkLines.forEach(line => {
                line.visible = networkActive;
            });
            document.querySelector('.control-btn:nth-child(2)').style.background = 
                networkActive ? 'rgba(0, 80, 120, 0.7)' : 'rgba(80, 0, 0, 0.7)';
        }
        
        function pulseEffect() {
            const pulseElement = document.getElementById('pulseEffect');
            pulseElement.style.background = 'radial-gradient(circle, rgba(0, 255, 255, 0.3), transparent 70%)';
            pulseElement.style.opacity = '0.5';
            
            // Create particle pulse
            createPulseParticles();
            
            // Animate pulse
            let opacity = 0.5;
            const pulseInterval = setInterval(() => {
                opacity -= 0.05;
                pulseElement.style.opacity = opacity;
                
                if (opacity <= 0) {
                    clearInterval(pulseInterval);
                    pulseElement.style.background = 'none';
                }
            }, 50);
        }
        
        function createPulseParticles() {
            // Create temporary pulse particles
            const particleCount = 50;
            const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true
            });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random direction from Earth
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                particle.position.x = CONFIG.EARTH_RADIUS * Math.sin(theta) * Math.cos(phi);
                particle.position.y = CONFIG.EARTH_RADIUS * Math.cos(theta);
                particle.position.z = CONFIG.EARTH_RADIUS * Math.sin(theta) * Math.sin(phi);
                
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    life: 1.0
                };
                
                scene.add(particle);
                
                // Animate and remove
                setTimeout(() => {
                    const interval = setInterval(() => {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.life -= 0.05;
                        particle.material.opacity = particle.userData.life;
                        
                        if (particle.userData.life <= 0) {
                            scene.remove(particle);
                            clearInterval(interval);
                        }
                    }, 50);
                }, i * 10);
            }
        }

        // ========== WINDOW RESIZE ==========
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            createGridOverlay();
        }

        // ========== INITIALIZE ==========
        function init() {
            console.log(`üöÄ Initializing ${BRSYSTEM.author}'s Earth Hologram System`);
            
            initThreeJS();
            animate();
            
            window.addEventListener('resize', onResize);
            
            // Initial system check
            setTimeout(() => {
                console.log('‚úÖ Earth Hologram System Online');
            }, 1000);
        }

        // Start everything
        init();
    </script>
</body>
</html>
