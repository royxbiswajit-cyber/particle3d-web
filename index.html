<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• ULTIMATE PARTICLE UNIVERSE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #container {
            position: fixed;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000010 100%);
        }
        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        #webcamContainer {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 280px;
            height: 210px;
            border: 3px solid #00ff88;
            border-radius: 15px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 30px #00ff88;
            display: none;
        }
        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            display: block;
        }
        .control-panel {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 100;
            background: rgba(10, 15, 30, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            max-width: 350px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        .title {
            color: #00ffff;
            margin-bottom: 20px;
            text-align: center;
            font-size: 28px;
            font-weight: 300;
            text-shadow: 0 0 20px #00ffff;
            letter-spacing: 1px;
        }
        .universe-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 25px;
        }
        .universe-btn {
            padding: 15px 10px;
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.4), rgba(100, 0, 200, 0.4));
            color: white;
            border: 1px solid rgba(0, 200, 255, 0.5);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }
        .universe-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 200, 255, 0.4);
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.6), rgba(150, 0, 255, 0.6));
        }
        .universe-btn.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            color: #000;
            font-weight: bold;
            border-color: #00ffff;
            box-shadow: 0 0 30px #00ffff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 20px #00ffff; }
            50% { box-shadow: 0 0 40px #ff00ff; }
            100% { box-shadow: 0 0 20px #00ffff; }
        }
        .control-section {
            background: rgba(0, 20, 40, 0.7);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 0 5px;
        }
        .control-label {
            width: 120px;
            color: #88ffff;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-container {
            flex: 1;
            position: relative;
            height: 30px;
            display: flex;
            align-items: center;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(90deg, #0066cc, #6600cc, #cc0066, #cc6600);
            border-radius: 3px;
            -webkit-appearance: none;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 3px solid #00ffff;
            box-shadow: 0 0 15px #00ffff;
            transition: all 0.3s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #00ffff;
        }
        .value-display {
            width: 60px;
            text-align: center;
            color: #ff88ff;
            font-weight: bold;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .stats-panel {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: rgba(0, 10, 25, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .stat-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .stat-label {
            color: #88ff88;
            opacity: 0.9;
        }
        .stat-value {
            color: #ffff88;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }
        .fps-counter {
            position: absolute;
            top: 25px;
            right: 25px;
            color: #00ff88;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 136, 0.5);
            backdrop-filter: blur(5px);
        }
        .hand-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            pointer-events: none;
            z-index: 90;
            transform: translate(-50%, -50%);
            display: none;
        }
        .hand-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 30px #ff0000;
            animation: rotate 10s linear infinite;
        }
        @keyframes rotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .hand-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            filter: drop-shadow(0 0 10px white);
        }
        .gesture-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            opacity: 0;
            pointer-events: none;
            z-index: 80;
            filter: drop-shadow(0 0 30px white);
            transition: all 0.5s;
        }
        .floating-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite alternate;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #00ffff;
            text-align: center;
            z-index: 200;
            display: none;
            max-width: 400px;
        }
        .notification h2 {
            color: #00ffff;
            margin-bottom: 15px;
        }
        .notification p {
            color: #ffffff;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .notification button {
            padding: 12px 30px;
            background: linear-gradient(45deg, #0066cc, #cc00cc);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .notification button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="mainCanvas"></canvas>
        <div class="floating-stars" id="starField"></div>
        
        <div id="webcamContainer">
            <video id="webcam" autoplay playsinline muted></video>
        </div>
        
        <div class="control-panel">
            <div class="title">‚ú® NEO PARTICLE UNIVERSE</div>
            
            <div class="universe-grid">
                <button class="universe-btn active" onclick="setUniverse('quantum')">‚öõÔ∏è QUANTUM</button>
                <button class="universe-btn" onclick="setUniverse('nebula')">üåÄ NEBULA</button>
                <button class="universe-btn" onclick="setUniverse('crystal')">üíé CRYSTAL</button>
                <button class="universe-btn" onclick="setUniverse('galaxy')">üåå GALAXY</button>
                <button class="universe-btn" onclick="setUniverse('energy')">‚ö° ENERGY</button>
                <button class="universe-btn" onclick="setUniverse('cosmic')">‚ú® COSMIC</button>
            </div>
            
            <div class="control-section">
                <div class="control-row">
                    <div class="control-label">üåÄ PARTICLES</div>
                    <div class="slider-container">
                        <input type="range" id="particleSlider" min="1000" max="20000" value="8000" step="500">
                    </div>
                    <div class="value-display" id="particleValue">8K</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">‚ö° INTENSITY</div>
                    <div class="slider-container">
                        <input type="range" id="intensitySlider" min="0.1" max="3.0" value="1.5" step="0.1">
                    </div>
                    <div class="value-display" id="intensityValue">1.5</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">üåü SIZE</div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="0.5" max="6.0" value="2.5" step="0.1">
                    </div>
                    <div class="value-display" id="sizeValue">2.5</div>
                </div>
            </div>
        </div>
        
        <div class="hand-indicator" id="handIndicator">
            <div class="hand-circle"></div>
            <div class="hand-emoji">üëã</div>
        </div>
        
        <div class="gesture-effect" id="gestureEffect">üëã</div>
        
        <div class="stats-panel">
            <div class="stat-item">
                <span class="stat-label">PARTICLES</span>
                <span class="stat-value" id="statParticles">8,000</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">UNIVERSE</span>
                <span class="stat-value" id="statUniverse">QUANTUM</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">CONTROL MODE</span>
                <span class="stat-value" id="statControl">MOUSE</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ENERGY LEVEL</span>
                <span class="stat-value" id="statEnergy">100%</span>
            </div>
        </div>
        
        <div class="fps-counter">FPS: <span id="fpsValue">60</span></div>
        
        <div class="notification" id="welcomeNotification">
            <h2>üéÆ WELCOME TO PARTICLE UNIVERSE</h2>
            <p>Move your mouse to control the particles!<br>
            Click and drag for different effects.<br>
            Use the UI to switch universes and adjust settings.</p>
            <button onclick="closeNotification()">START EXPERIENCE</button>
        </div>
    </div>

    <!-- Only Three.js - No other dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            particles: {
                count: 8000,
                size: 2.5,
                intensity: 1.5,
                attraction: 0.03,
                repulsion: 0.025,
                swirl: 0.04,
                turbulence: 0.02,
                friction: 0.95
            },
            camera: {
                distance: 40,
                smoothness: 0.08
            },
            universe: {
                quantum: { color: '#00ffff', speed: 1.5, chaos: 0.8 },
                nebula: { color: '#ff00ff', speed: 0.9, chaos: 0.4 },
                crystal: { color: '#00ff88', speed: 1.2, chaos: 0.2 },
                galaxy: { color: '#0088ff', speed: 1.8, chaos: 0.6 },
                energy: { color: '#ffff00', speed: 2.2, chaos: 0.9 },
                cosmic: { color: '#ffffff', speed: 2.0, chaos: 0.7 }
            }
        };

        // ========== GLOBAL VARIABLES ==========
        let scene, camera, renderer;
        let particleSystem;
        let particles = [];
        let currentUniverse = 'quantum';
        let time = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Mouse tracking
        let mouse = {
            x: 0.5,
            y: 0.5,
            down: false,
            rightDown: false,
            velocity: { x: 0, y: 0 },
            lastX: 0.5,
            lastY: 0.5
        };
        
        // Gesture tracking
        let currentGesture = 'none';
        let gestureStartTime = 0;
        let gestureEffects = {};

        // ========== INITIALIZE THREE.JS ==========
        function initThreeJS() {
            // Create advanced scene with fog
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.008);
            
            // Create camera with smooth damping
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camera.distance);
            camera.lookAt(0, 0, 0);
            
            // Create high-performance renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Create advanced lighting system
            createAdvancedLighting();
            
            // Create star field background
            createStarField();
            
            // Create particle system
            createAdvancedParticleSystem();
            
            console.log("üöÄ Advanced Three.js initialized");
        }

        // ========== CREATE ADVANCED LIGHTING ==========
        function createAdvancedLighting() {
            // Ambient light with color variation
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
            scene.add(ambientLight);
            
            // Main directional light with shadows
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
            mainLight.position.set(15, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.far = 100;
            scene.add(mainLight);
            
            // Colored accent lights
            const accentLight1 = new THREE.PointLight(0x00ffff, 1.2, 60);
            accentLight1.position.set(-20, 10, 15);
            scene.add(accentLight1);
            
            const accentLight2 = new THREE.PointLight(0xff00ff, 0.8, 60);
            accentLight2.position.set(20, -10, 15);
            scene.add(accentLight2);
            
            // Mouse-following light
            const mouseLight = new THREE.PointLight(0xffffff, 2, 40);
            mouseLight.position.set(0, 0, 20);
            scene.add(mouseLight);
            window.mouseLight = mouseLight;
        }

        // ========== CREATE STAR FIELD ==========
        function createStarField() {
            const starField = document.getElementById('starField');
            starField.innerHTML = '';
            
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = Math.random() * 4 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.opacity = Math.random() * 0.8 + 0.2;
                star.style.animationDuration = Math.random() * 2 + 2 + 's';
                starField.appendChild(star);
            }
        }

        // ========== CREATE ADVANCED PARTICLE SYSTEM ==========
        function createAdvancedParticleSystem() {
            // Remove existing system
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
            }
            
            particles = [];
            const count = CONFIG.particles.count;
            
            // Create buffer attributes
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = new Float32Array(count * 3);
            const phases = new Float32Array(count);
            
            const universeConfig = CONFIG.universe[currentUniverse];
            const baseColor = new THREE.Color(universeConfig.color);
            
            for (let i = 0; i < count; i++) {
                // Create unique particle distribution for each universe
                let x, y, z;
                
                switch(currentUniverse) {
                    case 'quantum':
                        // Quantum foam pattern
                        const q = i / count * Math.PI * 12;
                        const r = Math.pow(Math.random(), 1.8) * 25;
                        x = Math.cos(q * 3) * r * Math.sin(q * 2);
                        y = Math.sin(q * 2) * r * Math.cos(q * 1.5);
                        z = Math.sin(q * 4) * r * 0.8;
                        break;
                        
                    case 'nebula':
                        // Nebula cloud
                        const phi = Math.acos(2 * Math.random() - 1);
                        const theta = Math.random() * Math.PI * 2;
                        const radius = Math.pow(Math.random(), 0.7) * 22;
                        x = radius * Math.sin(phi) * Math.cos(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(phi);
                        break;
                        
                    case 'crystal':
                        // Geometric crystal lattice
                        const layer = Math.floor(i / (count / 10));
                        const angle = (i % (count / 10)) / (count / 10) * Math.PI * 2;
                        const crystalRadius = 10 + layer * 2.5;
                        x = Math.cos(angle) * crystalRadius;
                        y = Math.sin(angle) * crystalRadius;
                        z = (layer - 5) * 3.5 + Math.sin(angle * 4) * 2;
                        break;
                        
                    case 'galaxy':
                        // Spiral galaxy arms
                        const spiral = (i / count) * Math.PI * 18;
                        const galaxyRadius = Math.sqrt(i / count) * 20;
                        x = Math.cos(spiral) * galaxyRadius;
                        y = Math.sin(spiral) * galaxyRadius * 0.4;
                        z = Math.sin(spiral * 3) * 4;
                        break;
                        
                    case 'energy':
                        // Energy field
                        const energyAngle = Math.random() * Math.PI * 2;
                        const energyRadius = Math.random() * 18;
                        x = Math.cos(energyAngle) * energyRadius;
                        y = Math.sin(energyAngle) * energyRadius;
                        z = (Math.random() - 0.5) * 15;
                        break;
                        
                    case 'cosmic':
                        // Cosmic web structure
                        const cosmicAngle = (i / count) * Math.PI * 24;
                        const cosmicRadius = Math.sin(i * 0.02) * 15 + 10;
                        x = Math.cos(cosmicAngle) * cosmicRadius;
                        y = Math.sin(cosmicAngle * 1.7) * cosmicRadius;
                        z = Math.cos(cosmicAngle * 2.5) * 6;
                        break;
                }
                
                // Store particle data
                particles.push({
                    x, y, z,
                    vx: 0, vy: 0, vz: 0,
                    ox: x, oy: y, oz: z, // original positions
                    phase: Math.random() * Math.PI * 2,
                    size: Math.random() * 0.9 + 0.3,
                    color: new THREE.Color()
                        .copy(baseColor)
                        .offsetHSL(
                            (Math.random() - 0.5) * 0.25,
                            0.1,
                            (Math.random() - 0.5) * 0.15
                        ),
                    mass: Math.random() * 0.5 + 0.5
                });
                
                // Fill buffers
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
                
                sizes[i] = particles[i].size * CONFIG.particles.size;
                velocities[i * 3] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = 0;
                phases[i] = particles[i].phase;
            }
            
            // Create advanced geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
            
            // Advanced particle material
            const material = new THREE.PointsMaterial({
                size: CONFIG.particles.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Update UI
            updateStats();
            console.log(`üåÄ Created ${count.toLocaleString()} particles for ${currentUniverse} universe`);
        }

        // ========== SETUP MOUSE CONTROLS ==========
        function setupMouseControls() {
            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX / window.innerWidth;
                mouse.y = e.clientY / window.innerHeight;
                
                // Calculate velocity
                mouse.velocity.x = (mouse.x - mouse.lastX) * 50;
                mouse.velocity.y = (mouse.y - mouse.lastY) * 50;
                mouse.lastX = mouse.x;
                mouse.lastY = mouse.y;
                
                // Detect gestures from mouse movement
                detectMouseGesture();
                
                // Update hand indicator
                updateHandIndicator();
            });
            
            // Mouse down
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left click
                    mouse.down = true;
                    currentGesture = 'fist';
                    showGestureEffect('‚úä');
                } else if (e.button === 2) { // Right click
                    mouse.rightDown = true;
                    currentGesture = 'palm';
                    showGestureEffect('üñêÔ∏è');
                }
                e.preventDefault();
            });
            
            // Mouse up
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    mouse.down = false;
                    currentGesture = 'open';
                } else if (e.button === 2) {
                    mouse.rightDown = false;
                    currentGesture = 'open';
                }
            });
            
            // Prevent context menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Double click for special effects
            document.addEventListener('dblclick', () => {
                currentGesture = 'explode';
                showGestureEffect('üí•');
                createParticleBurst();
            });
            
            // Wheel for zoom
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                CONFIG.particles.size = Math.max(0.5, Math.min(6, 
                    CONFIG.particles.size - e.deltaY * 0.001));
                
                document.getElementById('sizeValue').textContent = CONFIG.particles.size.toFixed(1);
                
                if (particleSystem) {
                    particleSystem.material.size = CONFIG.particles.size;
                    const sizes = particleSystem.geometry.attributes.size.array;
                    for (let i = 0; i < particles.length; i++) {
                        sizes[i] = particles[i].size * CONFIG.particles.size;
                    }
                    particleSystem.geometry.attributes.size.needsUpdate = true;
                }
            }, { passive: false });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                const universes = ['quantum', 'nebula', 'crystal', 'galaxy', 'energy', 'cosmic'];
                const key = parseInt(e.key);
                
                if (key >= 1 && key <= 6) {
                    setUniverse(universes[key - 1]);
                }
                
                // Space for rainbow effect
                if (e.key === ' ') {
                    currentGesture = 'rainbow';
                    showGestureEffect('üåà');
                    shiftParticleColors();
                }
            });
        }

        // ========== DETECT MOUSE GESTURES ==========
        function detectMouseGesture() {
            const velocity = Math.sqrt(mouse.velocity.x * mouse.velocity.x + mouse.velocity.y * mouse.velocity.y);
            const now = Date.now();
            
            if (now - gestureStartTime > 300) {
                let newGesture = 'none';
                
                if (mouse.down) {
                    newGesture = 'fist';
                } else if (mouse.rightDown) {
                    newGesture = 'palm';
                } else if (velocity > 3) {
                    newGesture = 'swipe';
                } else if (velocity < 0.5) {
                    newGesture = 'still';
                } else {
                    newGesture = 'open';
                }
                
                if (newGesture !== currentGesture) {
                    currentGesture = newGesture;
                    gestureStartTime = now;
                    
                    // Apply gesture effects
                    applyGestureEffect(newGesture);
                }
            }
        }

        // ========== APPLY GESTURE EFFECTS ==========
        function applyGestureEffect(gesture) {
            const intensity = CONFIG.particles.intensity;
            
            // Clear previous effects
            gestureEffects = {};
            
            switch(gesture) {
                case 'fist':
                    gestureEffects.attraction = 0.06 * intensity;
                    break;
                    
                case 'palm':
                    gestureEffects.repulsion = 0.05 * intensity;
                    break;
                    
                case 'swipe':
                    gestureEffects.swirl = 0.08 * intensity;
                    break;
                    
                case 'still':
                    gestureEffects.freeze = true;
                    break;
                    
                case 'explode':
                    createParticleBurst();
                    break;
            }
            
            // Show visual feedback
            const emojis = {
                'fist': '‚úä', 'palm': 'üñêÔ∏è', 'swipe': 'üí®',
                'still': '‚ùÑÔ∏è', 'open': 'üëã', 'explode': 'üí•',
                'rainbow': 'üåà'
            };
            
            if (emojis[gesture]) {
                showGestureEffect(emojis[gesture]);
            }
        }

        // ========== UPDATE HAND INDICATOR ==========
        function updateHandIndicator() {
            const indicator = document.getElementById('handIndicator');
            const screenX = mouse.x * window.innerWidth;
            const screenY = mouse.y * window.innerHeight;
            
            indicator.style.left = screenX + 'px';
            indicator.style.top = screenY + 'px';
            indicator.style.display = 'block';
            
            // Update emoji based on gesture
            const emojis = {
                'fist': '‚úä', 'palm': 'üñêÔ∏è', 'swipe': 'üí®',
                'still': '‚ùÑÔ∏è', 'open': 'üëã', 'explode': 'üí•',
                'rainbow': 'üåà'
            };
            
            document.querySelector('.hand-emoji').textContent = emojis[currentGesture] || 'üëã';
            
            // Update color based on universe
            const universeConfig = CONFIG.universe[currentUniverse];
            document.querySelector('.hand-circle').style.borderColor = universeConfig.color;
            document.querySelector('.hand-circle').style.boxShadow = `0 0 40px ${universeConfig.color}`;
            
            // Scale based on mouse velocity
            const velocity = Math.sqrt(mouse.velocity.x * mouse.velocity.x + mouse.velocity.y * mouse.velocity.y);
            const scale = 0.8 + Math.min(velocity / 10, 0.6);
            indicator.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        // ========== SHOW GESTURE EFFECT ==========
        function showGestureEffect(emoji) {
            const effect = document.getElementById('gestureEffect');
            effect.textContent = emoji;
            effect.style.opacity = '1';
            effect.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            // Animate
            setTimeout(() => {
                effect.style.opacity = '0';
                effect.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 600);
        }

        // ========== SPECIAL EFFECTS ==========
        function createParticleBurst() {
            const burstStrength = 0.2 * CONFIG.particles.intensity;
            
            for (let i = 0; i < particles.length; i++) {
                if (Math.random() < 0.4) {
                    const angle = Math.random() * Math.PI * 2;
                    particles[i].vx += Math.cos(angle) * burstStrength;
                    particles[i].vy += Math.sin(angle) * burstStrength;
                    particles[i].vz += (Math.random() - 0.5) * burstStrength * 2;
                }
            }
        }

        function shiftParticleColors() {
            const colors = particleSystem.geometry.attributes.color.array;
            const universeConfig = CONFIG.universe[currentUniverse];
            const newColor = new THREE.Color(universeConfig.color);
            
            for (let i = 0; i < particles.length; i++) {
                particles[i].color.lerp(newColor, 0.15);
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }

        // ========== PARTICLE PHYSICS ENGINE ==========
        function updateParticlePhysics() {
            if (!particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            const phases = particleSystem.geometry.attributes.phase.array;
            
            // Convert mouse position to 3D space
            const mouseX3D = (mouse.x - 0.5) * 50;
            const mouseY3D = -(mouse.y - 0.5) * 35;
            
            // Update camera to follow mouse
            camera.position.x += (mouseX3D - camera.position.x) * CONFIG.camera.smoothness;
            camera.position.y += (mouseY3D - camera.position.y) * CONFIG.camera.smoothness;
            camera.lookAt(mouseX3D * 0.8, mouseY3D * 0.8, 0);
            
            // Update mouse-following light
            if (window.mouseLight) {
                window.mouseLight.position.set(mouseX3D, mouseY3D, 15);
                
                // Change light color based on universe
                const universeConfig = CONFIG.universe[currentUniverse];
                window.mouseLight.color.setStyle(universeConfig.color);
                window.mouseLight.intensity = 1.5 + Math.sin(time * 2) * 0.5;
            }
            
            const universeConfig = CONFIG.universe[currentUniverse];
            const baseSpeed = universeConfig.speed * CONFIG.particles.intensity;
            let totalEnergy = 0;
            
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const idx = i * 3;
                
                // Calculate distance to mouse
                const dx = mouseX3D - p.x;
                const dy = mouseY3D - p.y;
                const dz = -p.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.1;
                
                // Base natural movement based on universe
                const phase = phases[i] + time * baseSpeed * 0.5;
                
                switch(currentUniverse) {
                    case 'quantum':
                        p.vx += Math.sin(phase * 2.5 + i * 0.01) * 0.025;
                        p.vy += Math.cos(phase * 2 + i * 0.01) * 0.025;
                        p.vz += Math.sin(phase * 3.5) * 0.015;
                        break;
                        
                    case 'nebula':
                        p.vx += (Math.random() - 0.5) * 0.015 * universeConfig.chaos;
                        p.vy += (Math.random() - 0.5) * 0.015 * universeConfig.chaos;
                        p.vz += Math.sin(phase) * 0.008;
                        break;
                        
                    case 'crystal':
                        // Return to crystal lattice with spring force
                        const latticeForce = 0.015;
                        p.vx += (p.ox - p.x) * latticeForce;
                        p.vy += (p.oy - p.y) * latticeForce;
                        p.vz += (p.oz - p.z) * latticeForce;
                        break;
                        
                    case 'galaxy':
                        // Spiral rotation with vertical oscillation
                        const galaxyAngle = Math.atan2(p.z, p.x) + 0.008 * baseSpeed;
                        const galaxyRadius = Math.sqrt(p.x * p.x + p.z * p.z);
                        p.x = Math.cos(galaxyAngle) * galaxyRadius;
                        p.z = Math.sin(galaxyAngle) * galaxyRadius;
                        p.y += Math.sin(time + galaxyRadius * 0.2) * 0.02;
                        break;
                        
                    case 'energy':
                        // Chaotic energy field
                        p.vx += Math.sin(time * 3 + i * 0.02) * 0.03 * universeConfig.chaos;
                        p.vy += Math.cos(time * 2.5 + i * 0.02) * 0.03 * universeConfig.chaos;
                        p.vz += (Math.random() - 0.5) * 0.02;
                        break;
                        
                    case 'cosmic':
                        // Cosmic web movement
                        const webForce = 0.02;
                        p.vx += Math.sin(phase * 1.7) * webForce;
                        p.vy += Math.cos(phase * 1.3) * webForce;
                        p.vz += Math.sin(phase * 2.1) * webForce;
                        break;
                }
                
                // Apply gesture effects
                if (distance < 35) {
                    // Attraction from fist gesture
                    if (gestureEffects.attraction) {
                        const strength = gestureEffects.attraction / distance;
                        p.vx += dx * strength;
                        p.vy += dy * strength;
                        p.vz += dz * strength;
                    }
                    
                    // Repulsion from palm gesture
                    if (gestureEffects.repulsion) {
                        const strength = gestureEffects.repulsion / (distance * distance);
                        p.vx -= dx * strength;
                        p.vy -= dy * strength;
                        p.vz -= dz * strength;
                    }
                    
                    // Swirl from swipe gesture
                    if (gestureEffects.swirl) {
                        const angle = Math.atan2(dy, dx) + Math.PI / 2;
                        p.vx += Math.cos(angle) * gestureEffects.swirl;
                        p.vy += Math.sin(angle) * gestureEffects.swirl;
                    }
                    
                    // Freeze from still gesture
                    if (gestureEffects.freeze) {
                        p.vx *= 0.9;
                        p.vy *= 0.9;
                        p.vz *= 0.9;
                    }
                    
                    // Mouse velocity effects
                    const velocityEffect = 0.008 * CONFIG.particles.intensity;
                    p.vx += mouse.velocity.x * velocityEffect;
                    p.vy += -mouse.velocity.y * velocityEffect;
                }
                
                // Apply turbulence
                p.vx += (Math.sin(time * 3.5 + i * 0.1) * 0.015) * universeConfig.chaos;
                p.vy += (Math.cos(time * 2.8 + i * 0.1) * 0.015) * universeConfig.chaos;
                p.vz += (Math.sin(time * 2 + i * 0.1) * 0.01) * universeConfig.chaos;
                
                // Apply friction
                p.vx *= CONFIG.particles.friction;
                p.vy *= CONFIG.particles.friction;
                p.vz *= CONFIG.particles.friction;
                
                // Update position
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                // Update buffers
                positions[idx] = p.x;
                positions[idx + 1] = p.y;
                positions[idx + 2] = p.z;
                
                velocities[idx] = p.vx;
                velocities[idx + 1] = p.vy;
                velocities[idx + 2] = p.vz;
                
                // Color effects based on velocity
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy + p.vz * p.vz);
                const colorIntensity = Math.min(speed * 25, 1.2);
                
                colors[idx] = p.color.r * (0.8 + colorIntensity * 0.2);
                colors[idx + 1] = p.color.g * (0.8 + colorIntensity * 0.2);
                colors[idx + 2] = p.color.b * (0.8 + colorIntensity * 0.2);
                
                totalEnergy += speed;
            }
            
            // Mark buffers for update
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.velocity.needsUpdate = true;
            
            // Update energy stat
            const avgEnergy = (totalEnergy / particles.length) * 1200;
            document.getElementById('statEnergy').textContent = Math.round(avgEnergy) + '%';
        }

        // ========== UI CONTROLS ==========
        function setupUIControls() {
            // Particle count slider
            document.getElementById('particleSlider').addEventListener('input', (e) => {
                CONFIG.particles.count = parseInt(e.target.value);
                document.getElementById('particleValue').textContent = 
                    CONFIG.particles.count >= 10000 ? 
                    (CONFIG.particles.count/1000) + 'K' : 
                    CONFIG.particles.count.toLocaleString();
                createAdvancedParticleSystem();
            });
            
            // Intensity slider
            document.getElementById('intensitySlider').addEventListener('input', (e) => {
                CONFIG.particles.intensity = parseFloat(e.target.value);
                document.getElementById('intensityValue').textContent = 
                    CONFIG.particles.intensity.toFixed(1);
            });
            
            // Size slider
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                CONFIG.particles.size = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = 
                    CONFIG.particles.size.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = CONFIG.particles.size;
                    const sizes = particleSystem.geometry.attributes.size.array;
                    for (let i = 0; i < particles.length; i++) {
                        sizes[i] = particles[i].size * CONFIG.particles.size;
                    }
                    particleSystem.geometry.attributes.size.needsUpdate = true;
                }
            });
            
            // Universe buttons
            window.setUniverse = function(universe) {
                currentUniverse = universe;
                
                // Update active button
                document.querySelectorAll('.universe-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                // Recreate particle system
                createAdvancedParticleSystem();
                
                // Show universe transition effect
                showGestureEffect(getUniverseEmoji(universe));
            };
            
            // Close notification
            window.closeNotification = function() {
                document.getElementById('welcomeNotification').style.display = 'none';
            };
        }

        // ========== UTILITY FUNCTIONS ==========
        function getUniverseEmoji(universe) {
            const emojis = {
                'quantum': '‚öõÔ∏è', 'nebula': 'üåÄ', 'crystal': 'üíé',
                'galaxy': 'üåå', 'energy': '‚ö°', 'cosmic': '‚ú®'
            };
            return emojis[universe] || '‚ú®';
        }

        function updateStats() {
            document.getElementById('statParticles').textContent = 
                CONFIG.particles.count.toLocaleString();
            document.getElementById('statUniverse').textContent = 
                currentUniverse.toUpperCase();
            document.getElementById('statControl').textContent = 'MOUSE';
        }

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            
            if (now >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016 * CONFIG.particles.intensity;
            updateFPS();
            
            // Update particle physics
            updateParticlePhysics();
            
            // Update particle system
            if (particleSystem) {
                // Gentle system rotation
                particleSystem.rotation.y += 0.0015 * CONFIG.particles.intensity;
                particleSystem.rotation.x += 0.0007 * CONFIG.particles.intensity;
                
                // Particle size animation (breathing effect)
                const sizes = particleSystem.geometry.attributes.size.array;
                for (let i = 0; i < particles.length; i++) {
                    const pulse = Math.sin(time * 2.5 + particles[i].phase) * 0.25 + 0.85;
                    sizes[i] = particles[i].size * CONFIG.particles.size * pulse;
                }
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== INITIALIZE EVERYTHING ==========
        async function init() {
            try {
                console.log("üöÄ Initializing Particle Universe...");
                initThreeJS();
                setupUIControls();
                setupMouseControls();
                animate();
                
                // Show welcome notification
                setTimeout(() => {
                    document.getElementById('welcomeNotification').style.display = 'block';
                }, 1000);
                
                console.log("‚úÖ Particle Universe ready!");
                console.log("üéÆ Move mouse to control particles");
                console.log("üîë Press 1-6 to switch universes");
                console.log("üéØ Double-click for explosion effect");
                console.log("üåà Press SPACE for rainbow effect");
                
            } catch (error) {
                console.error("‚ùå Initialization error:", error);
            }
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
