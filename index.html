<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ ADVANCED HAND PARTICLE CONTROL</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        #container {
            position: fixed;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000010 100%);
        }
        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #webcamContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 3px solid #00ff88;
            border-radius: 15px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 30px #00ff88;
        }
        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            display: block;
        }
        #handOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 15, 30, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff00ff;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .title {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 15px #00ffff;
        }
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        .mode-btn {
            padding: 12px 5px;
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.6), rgba(100, 0, 200, 0.6));
            color: white;
            border: 1px solid rgba(0, 200, 255, 0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 200, 255, 0.5);
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #00ff88, #0088ff);
            color: #000;
            font-weight: bold;
            border-color: #00ffff;
            box-shadow: 0 0 25px #00ffff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 20px #00ffff; }
            50% { box-shadow: 0 0 35px #ff00ff; }
            100% { box-shadow: 0 0 20px #00ffff; }
        }
        .control-section {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 30, 60, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .control-label {
            width: 100px;
            color: #88ffff;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-container {
            flex: 1;
            margin: 0 10px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, #0066cc, #6600cc, #cc00cc);
            border-radius: 3px;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 15px #00ff88;
        }
        .value-display {
            width: 60px;
            text-align: center;
            color: #ff88ff;
            font-weight: bold;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
        }
        .hand-tracker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            pointer-events: none;
            z-index: 50;
            transform: translate(-50%, -50%);
            display: none;
        }
        .tracker-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid;
            border-radius: 50%;
            animation: rotate 10s linear infinite;
        }
        @keyframes rotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        .tracker-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            filter: drop-shadow(0 0 15px white);
        }
        .stats-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 10, 25, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        .stat-label {
            color: #88ff88;
        }
        .stat-value {
            color: #ffff88;
            font-weight: bold;
        }
        .fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #00ff88;
        }
        .gesture-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            opacity: 0;
            pointer-events: none;
            z-index: 60;
            filter: drop-shadow(0 0 30px white);
            transition: all 0.5s;
        }
        .camera-status {
            position: absolute;
            top: 20px;
            right: 150px;
            color: #ffaa00;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #ffaa00;
        }
        .zoom-display {
            position: absolute;
            bottom: 20px;
            right: 350px;
            color: #00ffff;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #00ffff;
        }
        .hand-gestures {
            position: absolute;
            top: 20px;
            right: 350px;
            background: rgba(0, 30, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff00ff;
            max-width: 250px;
        }
        .gesture-item {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .floating-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite alternate;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        .hand-trail {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 40;
        }
        .trail-dot {
            position: absolute;
            background: #00ffff;
            border-radius: 50%;
            opacity: 0.7;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="mainCanvas"></canvas>
        <div class="floating-stars" id="starField"></div>
        <div class="hand-trail" id="handTrail"></div>
        
        <div id="webcamContainer">
            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="handOverlay"></canvas>
        </div>
        
        <div class="control-panel">
            <div class="title">‚ú® HAND PARTICLE MAGIC</div>
            
            <div class="mode-grid">
                <button class="mode-btn active" onclick="setMode('follow')">üëã FOLLOW</button>
                <button class="mode-btn" onclick="setMode('attract')">‚úä ATTRACT</button>
                <button class="mode-btn" onclick="setMode('repel')">üñêÔ∏è REPEL</button>
                <button class="mode-btn" onclick="setMode('swirl')">üåÄ SWIRL</button>
                <button class="mode-btn" onclick="setMode('rainbow')">üåà RAINBOW</button>
                <button class="mode-btn" onclick="setMode('explode')">üí• EXPLODE</button>
            </div>
            
            <div class="control-section">
                <div class="control-row">
                    <div class="control-label">üåÄ PARTICLES</div>
                    <div class="slider-container">
                        <input type="range" id="particleSlider" min="1000" max="15000" value="5000" step="500">
                    </div>
                    <div class="value-display" id="particleValue">5000</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">‚ö° POWER</div>
                    <div class="slider-container">
                        <input type="range" id="powerSlider" min="0.1" max="3.0" value="1.5" step="0.1">
                    </div>
                    <div class="value-display" id="powerValue">1.5</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">üåü SIZE</div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="0.5" max="5.0" value="2.0" step="0.1">
                    </div>
                    <div class="value-display" id="sizeValue">2.0</div>
                </div>
            </div>
        </div>
        
        <div class="hand-tracker" id="handTracker">
            <div class="tracker-circle"></div>
            <div class="tracker-emoji">üëã</div>
        </div>
        
        <div class="gesture-popup" id="gesturePopup">üëã</div>
        
        <div class="hand-gestures">
            <div style="color:#ff00ff; font-weight:bold; margin-bottom:10px;">HAND GESTURES:</div>
            <div class="gesture-item">üëã Open = Follow Mode</div>
            <div class="gesture-item">‚úä Fist = Attract Particles</div>
            <div class="gesture-item">üñêÔ∏è Palm = Repel Particles</div>
            <div class="gesture-item">ü§ô Rock = Zoom In/Out</div>
            <div class="gesture-item">‚úåÔ∏è Peace = Change Colors</div>
            <div class="gesture-item">üëç Thumb = Reset All</div>
        </div>
        
        <div class="stats-panel">
            <div class="stat-item">
                <span class="stat-label">CAMERA:</span>
                <span class="stat-value" id="cameraStatus">OFF</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">HAND:</span>
                <span class="stat-value" id="handStatus">NO</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">GESTURE:</span>
                <span class="stat-value" id="gestureType">NONE</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ZOOM:</span>
                <span class="stat-value" id="zoomLevel">1.0x</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">MODE:</span>
                <span class="stat-value" id="currentMode">FOLLOW</span>
            </div>
        </div>
        
        <div class="fps-counter">FPS: <span id="fpsValue">0</span></div>
        <div class="camera-status" id="cameraStatusText">üé• STARTING...</div>
        <div class="zoom-display">üîç ZOOM: <span id="zoomValue">1.0x</span></div>
    </div>

    <!-- Three.js only -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ========== ADVANCED CONFIGURATION ==========
        const CONFIG = {
            particles: {
                count: 5000,
                size: 2.0,
                power: 1.5,
                attraction: 0.03,
                repulsion: 0.025,
                swirl: 0.04,
                friction: 0.95,
                turbulence: 0.02
            },
            camera: {
                baseDistance: 40,
                minDistance: 10,
                maxDistance: 100,
                smoothness: 0.08,
                zoomSpeed: 0.1
            },
            hand: {
                smoothing: 0.15,
                detectionThreshold: 800,
                gestureHoldTime: 500,
                trailLength: 20,
                skinColor: {
                    r: { min: 100, max: 255 },
                    g: { min: 60, max: 200 },
                    b: { min: 0, max: 140 }
                }
            }
        };

        // ========== GLOBAL VARIABLES ==========
        let scene, camera, renderer;
        let particleSystem;
        let particles = [];
        let currentMode = 'follow';
        let time = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Camera zoom
        let cameraDistance = CONFIG.camera.baseDistance;
        let targetZoom = 1.0;
        let currentZoom = 1.0;
        
        // Hand tracking
        let video;
        let handCanvas;
        let handCtx;
        let handData = {
            position: { x: 0.5, y: 0.5 },
            velocity: { x: 0, y: 0 },
            smooth: { x: 0.5, y: 0.5 },
            last: { x: 0.5, y: 0.5 },
            isDetected: false,
            gesture: 'none',
            gestureStart: 0,
            handSize: 0,
            handHistory: [],
            rockGesture: false,
            peaceGesture: false,
            thumbGesture: false
        };
        
        // Visual effects
        let trailDots = [];

        // ========== INITIALIZE THREE.JS ==========
        function initThreeJS() {
            // Create advanced scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, cameraDistance);
            
            // Create renderer with advanced settings
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Create advanced lighting
            createAdvancedLighting();
            
            // Create star field
            createStarField();
            
            // Create particle system
            createAdvancedParticleSystem();
            
            console.log("üöÄ Advanced Three.js initialized");
        }

        // ========== CREATE ADVANCED LIGHTING ==========
        function createAdvancedLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.9);
            mainLight.position.set(15, 15, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // Hand-following point light
            const handLight = new THREE.PointLight(0x00ffff, 2, 60);
            handLight.position.set(0, 0, 20);
            scene.add(handLight);
            window.handLight = handLight;
            
            // Accent lights
            const accentLight1 = new THREE.PointLight(0xff00ff, 0.8, 50);
            accentLight1.position.set(-20, 10, 15);
            scene.add(accentLight1);
            
            const accentLight2 = new THREE.PointLight(0x00ff88, 0.6, 50);
            accentLight2.position.set(20, -10, 15);
            scene.add(accentLight2);
        }

        // ========== CREATE STAR FIELD ==========
        function createStarField() {
            const starField = document.getElementById('starField');
            
            for (let i = 0; i < 150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.opacity = Math.random() * 0.7 + 0.3;
                starField.appendChild(star);
            }
        }

        // ========== CREATE ADVANCED PARTICLE SYSTEM ==========
        function createAdvancedParticleSystem() {
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
            }
            
            particles = [];
            const count = CONFIG.particles.count;
            
            // Create buffers
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = new Float32Array(count * 3);
            const phases = new Float32Array(count);
            
            for (let i = 0; i < count; i++) {
                // Create complex particle distribution
                const angle = (i / count) * Math.PI * 8;
                const radius = Math.pow(Math.random(), 1.5) * 25;
                const height = (Math.random() - 0.5) * 15;
                
                const x = Math.cos(angle) * radius * 0.8;
                const y = Math.sin(angle * 3) * 5 + height;
                const z = Math.sin(angle) * radius * 0.8;
                
                particles.push({
                    x, y, z,
                    vx: 0, vy: 0, vz: 0,
                    ox: x, oy: y, oz: z,
                    size: Math.random() * 0.9 + 0.3,
                    color: new THREE.Color(),
                    phase: Math.random() * Math.PI * 2,
                    mass: Math.random() * 0.5 + 0.5,
                    speed: Math.random() * 0.02 + 0.01
                });
                
                // Set positions
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Set colors with gradient
                const hue = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);
                particles[i].color.setHSL(hue, 0.9, 0.5);
                
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
                
                sizes[i] = particles[i].size * CONFIG.particles.size;
                phases[i] = particles[i].phase;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: CONFIG.particles.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            updateStats();
            console.log(`üåÄ Created ${count.toLocaleString()} particles`);
        }

        // ========== INITIALIZE WEBCAM ==========
        async function initWebcam() {
            try {
                updateCameraStatus('üé• REQUESTING CAMERA...', '#ffaa00');
                
                video = document.getElementById('webcam');
                
                // Get camera with optimal settings
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                // Setup hand overlay canvas
                handCanvas = document.getElementById('handOverlay');
                handCtx = handCanvas.getContext('2d');
                handCanvas.width = video.videoWidth;
                handCanvas.height = video.videoHeight;
                
                updateCameraStatus('üé• CAMERA ACTIVE', '#00ff88');
                
                // Start hand detection
                startAdvancedHandDetection();
                
            } catch (error) {
                console.error('Camera error:', error);
                updateCameraStatus('üé• CAMERA FAILED', '#ff0000');
                setupMouseControls();
            }
        }

        // ========== ADVANCED HAND DETECTION ==========
        function startAdvancedHandDetection() {
            let lastFrame = null;
            let frameCount = 0;
            
            function detectHandLoop() {
                if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
                    requestAnimationFrame(detectHandLoop);
                    return;
                }
                
                // Draw video
                handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
                handCtx.save();
                handCtx.scale(-1, 1);
                handCtx.drawImage(video, -handCanvas.width, 0, handCanvas.width, handCanvas.height);
                handCtx.restore();
                
                // Get frame data
                const frame = handCtx.getImageData(0, 0, handCanvas.width, handCanvas.height);
                
                // Detect hand with advanced algorithm
                detectHandWithAdvancedAlgorithm(frame);
                
                // Draw overlay
                drawAdvancedHandOverlay();
                
                // Add hand trail
                updateHandTrail();
                
                frameCount++;
                requestAnimationFrame(detectHandLoop);
            }
            
            detectHandLoop();
        }

        function detectHandWithAdvancedAlgorithm(frame) {
            let skinPixels = 0;
            let totalX = 0;
            let totalY = 0;
            let minX = handCanvas.width;
            let maxX = 0;
            let minY = handCanvas.height;
            let maxY = 0;
            
            // Analyze frame in chunks for performance
            const step = 4;
            for (let y = 0; y < handCanvas.height; y += step) {
                for (let x = 0; x < handCanvas.width; x += step) {
                    const index = (y * handCanvas.width + x) * 4;
                    const r = frame.data[index];
                    const g = frame.data[index + 1];
                    const b = frame.data[index + 2];
                    
                    // Advanced skin detection
                    const isSkin = (
                        r > CONFIG.hand.skinColor.r.min &&
                        g > CONFIG.hand.skinColor.g.min &&
                        g < CONFIG.hand.skinColor.g.max &&
                        b < CONFIG.hand.skinColor.b.max &&
                        r > g * 1.1 &&
                        r > b * 1.2 &&
                        Math.abs(r - g) > 20
                    );
                    
                    if (isSkin) {
                        skinPixels++;
                        totalX += x;
                        totalY += y;
                        
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // Check if enough skin pixels detected
            if (skinPixels > CONFIG.hand.detectionThreshold) {
                handData.isDetected = true;
                
                // Calculate hand center (mirrored for display)
                const centerX = 1 - (totalX / skinPixels) / handCanvas.width;
                const centerY = (totalY / skinPixels) / handCanvas.height;
                
                // Smooth hand position
                handData.position.x = centerX;
                handData.position.y = centerY;
                
                handData.smooth.x += (centerX - handData.smooth.x) * CONFIG.hand.smoothing;
                handData.smooth.y += (centerY - handData.smooth.y) * CONFIG.hand.smoothing;
                
                // Calculate velocity
                handData.velocity.x = (handData.smooth.x - handData.last.x) * 30;
                handData.velocity.y = (handData.smooth.y - handData.last.y) * 30;
                handData.last.x = handData.smooth.x;
                handData.last.y = handData.smooth.y;
                
                // Calculate hand size
                const handWidth = (maxX - minX) / handCanvas.width;
                const handHeight = (maxY - minY) / handCanvas.height;
                handData.handSize = Math.sqrt(handWidth * handWidth + handHeight * handHeight);
                
                // Detect advanced gestures
                detectAdvancedGestures(frame, minX, maxX, minY, maxY);
                
                // Update hand history
                handData.handHistory.push({
                    x: handData.smooth.x,
                    y: handData.smooth.y,
                    time: Date.now()
                });
                
                if (handData.handHistory.length > 50) {
                    handData.handHistory.shift();
                }
                
                updateUIStatus(true);
                
            } else {
                handData.isDetected = false;
                updateUIStatus(false);
            }
        }

        function detectAdvancedGestures(frame, minX, maxX, minY, maxY) {
            const handWidth = maxX - minX;
            const handHeight = maxY - minY;
            const aspectRatio = handWidth / handHeight;
            const now = Date.now();
            
            let newGesture = 'none';
            
            // Check gesture based on hand properties
            if (handData.handSize < 0.1) {
                newGesture = 'fist';
            } else if (handData.handSize > 0.25) {
                newGesture = 'palm';
            } else if (Math.abs(handData.velocity.x) > Math.abs(handData.velocity.y) * 2) {
                newGesture = 'swipe';
            } else {
                newGesture = 'open';
            }
            
            // Check for special gestures
            if (aspectRatio > 1.5) {
                handData.rockGesture = true;
                newGesture = 'rock';
            } else {
                handData.rockGesture = false;
            }
            
            // Detect peace sign (two fingers up)
            if (handData.handSize > 0.2 && aspectRatio < 0.8) {
                handData.peaceGesture = true;
                newGesture = 'peace';
            } else {
                handData.peaceGesture = false;
            }
            
            // Detect thumb up
            if (handData.handSize > 0.15 && handData.handSize < 0.22) {
                handData.thumbGesture = true;
                newGesture = 'thumb';
            } else {
                handData.thumbGesture = false;
            }
            
            // Update gesture if changed
            if (newGesture !== handData.gesture) {
                handData.gesture = newGesture;
                handData.gestureStart = now;
                onGestureChanged(newGesture);
            }
        }

        function onGestureChanged(gesture) {
            const now = Date.now();
            if (now - handData.gestureStart < 200) return;
            
            // Show gesture visual
            showGestureEffect(getGestureEmoji(gesture));
            
            // Apply gesture effects
            applyGestureEffect(gesture);
            
            console.log(`üé≠ Gesture: ${gesture}`);
        }

        function getGestureEmoji(gesture) {
            const emojis = {
                'fist': '‚úä', 'palm': 'üñêÔ∏è', 'open': 'üëã', 'swipe': 'üí®',
                'rock': 'ü§ô', 'peace': '‚úåÔ∏è', 'thumb': 'üëç'
            };
            return emojis[gesture] || 'üëã';
        }

        function applyGestureEffect(gesture) {
            switch(gesture) {
                case 'rock':
                    // Rock gesture for zoom
                    if (handData.handSize > 0.2) {
                        // Zoom in
                        targetZoom = Math.min(3.0, currentZoom + 0.3);
                    } else {
                        // Zoom out
                        targetZoom = Math.max(0.3, currentZoom - 0.3);
                    }
                    break;
                    
                case 'peace':
                    // Peace gesture - change colors
                    shiftParticleColors();
                    break;
                    
                case 'thumb':
                    // Thumb up - reset everything
                    resetParticles();
                    targetZoom = 1.0;
                    break;
                    
                case 'fist':
                    // Strong attraction
                    currentMode = 'attract';
                    updateModeUI();
                    break;
                    
                case 'palm':
                    // Strong repulsion
                    currentMode = 'repel';
                    updateModeUI();
                    break;
            }
        }

        function drawAdvancedHandOverlay() {
            if (!handData.isDetected) return;
            
            const ctx = handCtx;
            const x = (1 - handData.smooth.x) * handCanvas.width;
            const y = handData.smooth.y * handCanvas.height;
            
            // Draw hand center
            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(x, y, handData.handSize * handCanvas.width * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw hand outline
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, handData.handSize * handCanvas.width * 1.5, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw velocity vector
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + handData.velocity.x * 2, y + handData.velocity.y * 2);
            ctx.stroke();
            
            // Draw gesture text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(handData.gesture.toUpperCase(), x, y - handData.handSize * handCanvas.width * 2 - 10);
            
            // Draw zoom indicator if rock gesture
            if (handData.rockGesture) {
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('üîç ZOOM', x, y + handData.handSize * handCanvas.width * 2 + 30);
            }
        }

        function updateHandTrail() {
            if (!handData.isDetected) return;
            
            const trail = document.getElementById('handTrail');
            
            // Add new trail dot
            const dot = document.createElement('div');
            dot.className = 'trail-dot';
            dot.style.width = '10px';
            dot.style.height = '10px';
            dot.style.left = (handData.smooth.x * 100) + '%';
            dot.style.top = (handData.smooth.y * 100) + '%';
            dot.style.background = getModeColor(currentMode);
            dot.style.opacity = '0.7';
            
            trail.appendChild(dot);
            trailDots.push({
                element: dot,
                time: Date.now(),
                x: handData.smooth.x,
                y: handData.smooth.y
            });
            
            // Remove old dots
            const now = Date.now();
            while (trailDots.length > 0 && now - trailDots[0].time > 2000) {
                const oldDot = trailDots.shift();
                if (oldDot.element.parentNode) {
                    oldDot.element.parentNode.removeChild(oldDot.element);
                }
            }
            
            // Fade out dots
            trailDots.forEach((dot, index) => {
                const age = now - dot.time;
                const opacity = 0.7 * (1 - age / 2000);
                dot.element.style.opacity = opacity.toString();
                
                // Move dots slightly for motion effect
                const offset = index * 0.5;
                dot.element.style.left = (dot.x * 100 + Math.sin(time + index) * offset) + '%';
                dot.element.style.top = (dot.y * 100 + Math.cos(time + index) * offset) + '%';
            });
        }

        // ========== PARTICLE PHYSICS ENGINE ==========
        function updateParticlePhysics() {
            if (!particleSystem || !handData.isDetected) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            
            // Convert hand position to 3D space
            const handX = (handData.smooth.x - 0.5) * 40 * currentZoom;
            const handY = -(handData.smooth.y - 0.5) * 30 * currentZoom;
            
            // Update camera with zoom
            cameraDistance = CONFIG.camera.baseDistance / currentZoom;
            camera.position.z = cameraDistance;
            
            // Smooth camera follow
            camera.position.x += (handX - camera.position.x) * CONFIG.camera.smoothness;
            camera.position.y += (handY - camera.position.y) * CONFIG.camera.smoothness;
            camera.lookAt(handX * 0.8, handY * 0.8, 0);
            
            // Update hand light
            if (window.handLight) {
                window.handLight.position.set(handX, handY, 10);
                window.handLight.color.setStyle(getModeColor(currentMode));
                window.handLight.intensity = 1.5 + Math.sin(time * 2) * 0.5;
            }
            
            const power = CONFIG.particles.power;
            let totalEnergy = 0;
            
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const idx = i * 3;
                
                // Calculate distance to hand
                const dx = handX - p.x;
                const dy = handY - p.y;
                const dz = -p.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz) + 1;
                
                // Apply mode-specific forces
                let forceX = 0, forceY = 0, forceZ = 0;
                
                switch(currentMode) {
                    case 'attract':
                        const attractForce = CONFIG.particles.attraction * power / distance;
                        forceX = dx * attractForce;
                        forceY = dy * attractForce;
                        forceZ = dz * attractForce;
                        break;
                        
                    case 'repel':
                        const repelForce = CONFIG.particles.repulsion * power / (distance * distance);
                        forceX = -dx * repelForce;
                        forceY = -dy * repelForce;
                        forceZ = -dz * repelForce;
                        break;
                        
                    case 'swirl':
                        const swirlForce = CONFIG.particles.swirl * power;
                        const angle = Math.atan2(dy, dx) + Math.PI/2;
                        forceX = Math.cos(angle) * swirlForce;
                        forceY = Math.sin(angle) * swirlForce;
                        break;
                        
                    case 'rainbow':
                        // Color cycling
                        const hue = (time * 0.5 + i * 0.001) % 1;
                        p.color.setHSL(hue, 0.9, 0.5);
                        colors[idx] = p.color.r;
                        colors[idx + 1] = p.color.g;
                        colors[idx + 2] = p.color.b;
                        break;
                        
                    case 'explode':
                        if (distance < 20) {
                            const explodeForce = 0.15 * power;
                            forceX = dx * explodeForce;
                            forceY = dy * explodeForce;
                            forceZ = (Math.random() - 0.5) * 2;
                        }
                        break;
                        
                    case 'follow':
                    default:
                        const followForce = 0.02 * power / distance;
                        forceX = handData.velocity.x * followForce;
                        forceY = -handData.velocity.y * followForce;
                        break;
                }
                
                // Add turbulence
                const turbulence = CONFIG.particles.turbulence * power;
                forceX += Math.sin(time * 3 + i * 0.01) * turbulence;
                forceY += Math.cos(time * 2.5 + i * 0.01) * turbulence;
                forceZ += Math.sin(time * 1.5 + i * 0.01) * turbulence * 0.5;
                
                // Apply forces
                p.vx += forceX / p.mass;
                p.vy += forceY / p.mass;
                p.vz += forceZ / p.mass;
                
                // Return to original position
                const returnForce = 0.01 * power;
                p.vx += (p.ox - p.x) * returnForce;
                p.vy += (p.oy - p.y) * returnForce;
                p.vz += (p.oz - p.z) * returnForce;
                
                // Apply friction
                p.vx *= CONFIG.particles.friction;
                p.vy *= CONFIG.particles.friction;
                p.vz *= CONFIG.particles.friction;
                
                // Update position
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                // Update buffers
                positions[idx] = p.x;
                positions[idx + 1] = p.y;
                positions[idx + 2] = p.z;
                
                velocities[idx] = p.vx;
                velocities[idx + 1] = p.vy;
                velocities[idx + 2] = p.vz;
                
                // Color intensity based on velocity
                const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy + p.vz*p.vz);
                const intensity = Math.min(speed * 30, 1.5);
                
                if (currentMode !== 'rainbow') {
                    colors[idx] = p.color.r * (0.7 + intensity * 0.3);
                    colors[idx + 1] = p.color.g * (0.7 + intensity * 0.3);
                    colors[idx + 2] = p.color.b * (0.7 + intensity * 0.3);
                }
                
                totalEnergy += speed;
            }
            
            // Update buffers
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.velocity.needsUpdate = true;
        }

        // ========== SPECIAL EFFECTS ==========
        function shiftParticleColors() {
            const colors = particleSystem.geometry.attributes.color.array;
            
            for (let i = 0; i < particles.length; i++) {
                const hue = (Math.random() * 0.3 + time * 0.1) % 1;
                particles[i].color.setHSL(hue, 0.9, 0.5);
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            showGestureEffect('üåà');
        }

        function resetParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.vx = p.vy = p.vz = 0;
                p.x = p.ox;
                p.y = p.oy;
                p.z = p.oz;
            }
            
            showGestureEffect('üîÑ');
        }

        // ========== MOUSE CONTROLS (FALLBACK) ==========
        function setupMouseControls() {
            let mouseX = 0.5, mouseY = 0.5;
            let mouseDown = false;
            let rightDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX / window.innerWidth;
                mouseY = e.clientY / window.innerHeight;
                
                handData.smooth.x = mouseX;
                handData.smooth.y = mouseY;
                handData.isDetected = true;
                handData.gesture = mouseDown ? 'fist' : (rightDown ? 'palm' : 'open');
                
                updateHandTracker();
                updateUIStatus(true);
            });
            
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) mouseDown = true;
                if (e.button === 2) rightDown = true;
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouseDown = false;
                if (e.button === 2) rightDown = false;
            });
            
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mouse wheel for zoom
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetZoom = Math.max(0.3, Math.min(3.0, 
                    targetZoom - e.deltaY * 0.001));
            }, { passive: false });
            
            // Double click for explosion
            document.addEventListener('dblclick', () => {
                handData.gesture = 'explode';
                showGestureEffect('üí•');
                currentMode = 'explode';
                updateModeUI();
            });
        }

        // ========== UI UPDATES ==========
        function updateHandTracker() {
            const tracker = document.getElementById('handTracker');
            const screenX = handData.smooth.x * window.innerWidth;
            const screenY = handData.smooth.y * window.innerHeight;
            
            tracker.style.left = screenX + 'px';
            tracker.style.top = screenY + 'px';
            tracker.style.display = 'block';
            
            // Update tracker appearance
            document.querySelector('.tracker-emoji').textContent = getGestureEmoji(handData.gesture);
            document.querySelector('.tracker-circle').style.borderColor = getModeColor(currentMode);
            document.querySelector('.tracker-circle').style.boxShadow = `0 0 40px ${getModeColor(currentMode)}`;
            
            // Scale based on zoom
            const scale = 0.8 + (currentZoom - 1) * 0.5;
            tracker.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        function showGestureEffect(emoji) {
            const popup = document.getElementById('gesturePopup');
            popup.textContent = emoji;
            popup.style.opacity = '1';
            popup.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            setTimeout(() => {
                popup.style.opacity = '0';
                popup.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 600);
        }

        function updateUIStatus(isDetected) {
            document.getElementById('handStatus').textContent = isDetected ? 'YES' : 'NO';
            document.getElementById('gestureType').textContent = handData.gesture.toUpperCase();
            document.getElementById('currentMode').textContent = currentMode.toUpperCase();
            
            if (isDetected) {
                document.getElementById('cameraStatus').textContent = 'ACTIVE';
                document.getElementById('cameraStatus').style.color = '#00ff88';
            }
        }

        function updateCameraStatus(text, color) {
            document.getElementById('cameraStatusText').textContent = text;
            document.getElementById('cameraStatusText').style.color = color;
            document.getElementById('cameraStatusText').style.borderColor = color;
        }

        function updateStats() {
            document.getElementById('particleValue').textContent = CONFIG.particles.count.toLocaleString();
        }

        function updateModeUI() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(currentMode.toUpperCase())) {
                    btn.classList.add('active');
                }
            });
        }

        function getModeColor(mode) {
            const colors = {
                'follow': '#00ffff', 'attract': '#ff0000', 'repel': '#00ff00',
                'swirl': '#ff00ff', 'rainbow': '#ffff00', 'explode': '#ff8800'
            };
            return colors[mode] || '#00ffff';
        }

        // ========== UI CONTROLS ==========
        function setupUIControls() {
            // Particle count
            document.getElementById('particleSlider').addEventListener('input', (e) => {
                CONFIG.particles.count = parseInt(e.target.value);
                document.getElementById('particleValue').textContent = CONFIG.particles.count.toLocaleString();
                createAdvancedParticleSystem();
            });
            
            // Power
            document.getElementById('powerSlider').addEventListener('input', (e) => {
                CONFIG.particles.power = parseFloat(e.target.value);
                document.getElementById('powerValue').textContent = CONFIG.particles.power.toFixed(1);
            });
            
            // Size
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                CONFIG.particles.size = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = CONFIG.particles.size.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = CONFIG.particles.size;
                }
            });
            
            // Mode buttons
            window.setMode = function(mode) {
                currentMode = mode;
                updateModeUI();
                showGestureEffect(getModeEmoji(mode));
            };
            
            function getModeEmoji(mode) {
                const emojis = {
                    'follow': 'üëã', 'attract': '‚úä', 'repel': 'üñêÔ∏è',
                    'swirl': 'üåÄ', 'rainbow': 'üåà', 'explode': 'üí•'
                };
                return emojis[mode] || 'üåÄ';
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                const modes = ['follow', 'attract', 'repel', 'swirl', 'rainbow', 'explode'];
                const key = parseInt(e.key);
                if (key >= 1 && key <= 6) {
                    setMode(modes[key - 1]);
                }
                
                // Space for rainbow
                if (e.key === ' ') {
                    setMode('rainbow');
                    shiftParticleColors();
                }
                
                // Z for zoom reset
                if (e.key.toLowerCase() === 'z') {
                    targetZoom = 1.0;
                }
            });
        }

        // ========== UPDATE FPS ==========
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            
            if (now >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fpsValue').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016 * CONFIG.particles.power;
            updateFPS();
            
            // Update zoom smoothly
            currentZoom += (targetZoom - currentZoom) * CONFIG.camera.zoomSpeed;
            document.getElementById('zoomValue').textContent = currentZoom.toFixed(1) + 'x';
            document.getElementById('zoomLevel').textContent = currentZoom.toFixed(1) + 'x';
            
            // Update particle physics
            updateParticlePhysics();
            
            // Update particle system
            if (particleSystem) {
                // Gentle rotation
                particleSystem.rotation.y += 0.001 * CONFIG.particles.power;
                particleSystem.rotation.x += 0.0005 * CONFIG.particles.power;
                
                // Particle breathing
                const sizes = particleSystem.geometry.attributes.size.array;
                for (let i = 0; i < particles.length; i++) {
                    const pulse = Math.sin(time * 2.5 + particles[i].phase) * 0.25 + 0.85;
                    sizes[i] = particles[i].size * CONFIG.particles.size * pulse;
                }
                particleSystem.geometry.attributes.size.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== INITIALIZE EVERYTHING ==========
        async function init() {
            try {
                console.log("üöÄ Starting Advanced Hand Control...");
                initThreeJS();
                setupUIControls();
                await initWebcam();
                animate();
                
                console.log("‚úÖ System ready!");
                console.log("üëã Show hand to camera");
                console.log("ü§ô Rock gesture = Zoom In/Out");
                console.log("‚úåÔ∏è Peace = Change colors");
                console.log("üëç Thumb = Reset all");
                console.log("üîë 1-6 = Change modes");
                
            } catch (error) {
                console.error("‚ùå Error:", error);
            }
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
