<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BR Earth System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        
        /* Ultra Minimal Branding */
        .brand {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
        }
        
        .brand-name {
            font-size: 20px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }
        
        .brand-subtitle {
            font-size: 10px;
            font-weight: 300;
            letter-spacing: 2px;
            opacity: 0.6;
            text-transform: uppercase;
            margin-top: 1px;
        }
        
        /* Performance Indicator */
        .performance {
            position: absolute;
            top: 25px;
            right: 25px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        
        .performance span {
            color: #00ff88;
        }
        
        /* Connection Quality */
        .connection {
            position: absolute;
            top: 45px;
            right: 25px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.6);
            font-size: 9px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ff88;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    
    <!-- Minimal Branding -->
    <div class="brand">
        <div class="brand-name">BISWAJIT ROY</div>
        <div class="brand-subtitle">EARTH CONTROL v4.0</div>
    </div>
    
    <!-- Performance Indicator -->
    <div class="performance">
        <span id="fpsCounter">60</span> FPS
    </div>
    
    <!-- Connection Quality -->
    <div class="connection">
        <div class="connection-dot"></div>
        <span id="connectionStatus">STABLE</span>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ========== OPTIMIZED EARTH CONTROL SYSTEM ==========
        console.time('System Init');
        
        const SYSTEM = {
            version: "4.0",
            author: "BISWAJIT ROY",
            performance: {
                targetFPS: 60,
                frameTime: 16.67,
                lastFrame: 0,
                fpsHistory: [],
                stability: 100
            }
        };

        // ========== CONFIGURATION ==========
        const CONFIG = {
            // Performance
            MAX_PARTICLES: 8000,
            EARTH_SEGMENTS: 96,
            ENABLE_SHADOWS: false,
            
            // Earth
            EARTH_RADIUS: 4.5,
            AUTO_ROTATION: 0.001,
            
            // Camera
            CAMERA_DISTANCE: 16,
            CAMERA_MIN: 8,
            CAMERA_MAX: 30,
            CAMERA_SMOOTH: 0.12,
            
            // Hand Tracking (Optimized)
            HAND_SMOOTHING: 0.25,
            VELOCITY_SMOOTHING: 0.3,
            DEADZONE: 0.01,
            
            // Control Sensitivity
            ROTATION_SENSITIVITY: 3.0,
            ZOOM_SENSITIVITY: 0.02,
            INERTIA_DECAY: 0.92,
            
            // Gesture Detection
            GESTURE_CONFIDENCE: 0.7,
            PINCH_THRESHOLD: 0.04,
            FIST_THRESHOLD: 0.15
        };

        // ========== STATE VARIABLES ==========
        let scene, camera, renderer;
        let earth, clouds, atmosphere;
        let earthGroup;
        
        // Optimized Hand State
        let hand = {
            detected: false,
            confidence: 0,
            position: { x: 0.5, y: 0.5 },
            velocity: { x: 0, y: 0 },
            smoothed: { x: 0.5, y: 0.5 },
            smoothedVel: { x: 0, y: 0 },
            lastUpdate: 0,
            frameTime: 0,
            
            // Gestures with confidence
            gestures: {
                open: { active: false, confidence: 0 },
                fist: { active: false, confidence: 0 },
                pinch: { active: false, confidence: 0 },
                twoFingers: { active: false, confidence: 0 }
            },
            
            // Control state
            rotation: { x: 0, y: 0 },
            zoom: 1.0,
            inertia: { x: 0, y: 0, z: 0 }
        };
        
        // Camera State
        let cameraTarget = {
            distance: CONFIG.CAMERA_DISTANCE,
            rotation: { x: 0, y: 0 }
        };
        
        // Performance Tracking
        let frameCount = 0;
        let lastFPSUpdate = 0;
        let video;
        let handTracker;
        let isTracking = false;

        // ========== INIT THREE.JS (OPTIMIZED) ==========
        function initThreeJS() {
            // Scene with minimal fog
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 30, 100);
            
            // Camera with optimal FOV
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.z = CONFIG.CAMERA_DISTANCE;
            
            // Optimized Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Reduced for performance
            renderer.setClearColor(0x000000);
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            if (CONFIG.ENABLE_SHADOWS) {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }
            
            // Create optimized Earth
            createOptimizedEarth();
            
            // Create minimal starfield
            createMinimalStars();
            
            // Setup efficient lighting
            setupEfficientLighting();
            
            console.timeEnd('System Init');
            console.log("âœ… Three.js initialized (Optimized)");
        }

        // ========== CREATE OPTIMIZED EARTH ==========
        function createOptimizedEarth() {
            earthGroup = new THREE.Group();
            scene.add(earthGroup);
            
            // Optimized Earth geometry
            const earthGeometry = new THREE.SphereGeometry(
                CONFIG.EARTH_RADIUS, 
                CONFIG.EARTH_SEGMENTS, 
                CONFIG.EARTH_SEGMENTS
            );
            
            // Efficient Earth material
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x4488ff,
                specular: 0x111111,
                shininess: 10,
                transparent: false
            });
            
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.castShadow = CONFIG.ENABLE_SHADOWS;
            earth.receiveShadow = CONFIG.ENABLE_SHADOWS;
            earthGroup.add(earth);
            
            // Simple cloud layer
            const cloudGeometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS * 1.01, 48, 48);
            const cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2,
                depthWrite: false
            });
            
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            earthGroup.add(clouds);
            
            // Atmosphere effect (shader removed for performance)
            const atmosphereGeometry = new THREE.SphereGeometry(CONFIG.EARTH_RADIUS * 1.08, 32, 32);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                transparent: true,
                opacity: 0.08,
                side: THREE.BackSide
            });
            
            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthGroup.add(atmosphere);
            
            // Initial rotation
            earthGroup.rotation.x = -0.3;
        }

        // ========== CREATE MINIMAL STARS ==========
        function createMinimalStars() {
            const starCount = 1500;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                // Spherical distribution
                const radius = 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                color: 0xffffff,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // ========== SETUP EFFICIENT LIGHTING ==========
        function setupEfficientLighting() {
            // Single directional light
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(50, 30, 50);
            sunLight.castShadow = CONFIG.ENABLE_SHADOWS;
            scene.add(sunLight);
            
            // Ambient light only
            const ambient = new THREE.AmbientLight(0x224466, 0.3);
            scene.add(ambient);
        }

        // ========== INITIALIZE CAMERA ==========
        async function initCamera() {
            video = document.createElement('video');
            video.style.display = 'none';
            document.body.appendChild(video);
            
            try {
                // Optimized camera settings
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "user",
                        width: { ideal: 480 }, // Reduced resolution
                        height: { ideal: 360 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                await video.play();
                
                // Start optimized hand tracking
                startOptimizedTracking();
                
                updateConnectionStatus("TRACKING");
                return true;
            } catch (error) {
                console.warn("Camera not available, running in demo mode");
                updateConnectionStatus("DEMO MODE");
                startDemoMode();
                return false;
            }
        }

        // ========== START OPTIMIZED TRACKING ==========
        function startOptimizedTracking() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            // Optimized settings
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Reduced complexity for speed
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6,
                selfieMode: true
            });
            
            hands.onResults((results) => {
                if (!isTracking) return;
                processHandFrame(results);
            });
            
            handTracker = new Camera(video, {
                onFrame: async () => {
                    if (isTracking) {
                        try {
                            await hands.send({image: video});
                        } catch (e) {
                            // Skip frame on error
                        }
                    }
                },
                width: 480,
                height: 360
            });
            
            handTracker.start();
            isTracking = true;
            console.log("âœ… Hand tracking started (Optimized)");
        }

        // ========== PROCESS HAND FRAME (OPTIMIZED) ==========
        function processHandFrame(results) {
            const now = performance.now();
            hand.frameTime = now - hand.lastUpdate;
            hand.lastUpdate = now;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Calculate palm center (optimized)
                let sumX = 0, sumY = 0;
                for (let i = 0; i < 5; i++) {
                    sumX += landmarks[i*4].x;
                    sumY += landmarks[i*4].y;
                }
                
                const newX = sumX / 5;
                const newY = sumY / 5;
                
                // Calculate velocity
                hand.velocity.x = newX - hand.position.x;
                hand.velocity.y = newY - hand.position.y;
                
                // Update position
                hand.position.x = newX;
                hand.position.y = newY;
                
                // Smooth position with velocity prediction
                const smoothFactor = CONFIG.HAND_SMOOTHING;
                const velFactor = CONFIG.VELOCITY_SMOOTHING;
                
                hand.smoothed.x += (hand.position.x + hand.velocity.x * velFactor - hand.smoothed.x) * smoothFactor;
                hand.smoothed.y += (hand.position.y + hand.velocity.y * velFactor - hand.smoothed.y) * smoothFactor;
                hand.smoothedVel.x += (hand.velocity.x - hand.smoothedVel.x) * smoothFactor;
                hand.smoothedVel.y += (hand.velocity.y - hand.smoothedVel.y) * smoothFactor;
                
                // Detect gestures (optimized)
                detectOptimizedGestures(landmarks);
                
                hand.detected = true;
                hand.confidence = Math.min(1.0, hand.confidence + 0.1);
                
            } else {
                hand.detected = false;
                hand.confidence = Math.max(0, hand.confidence - 0.05);
            }
        }

        // ========== DETECT OPTIMIZED GESTURES ==========
        function detectOptimizedGestures(landmarks) {
            const thumb = landmarks[4];
            const index = landmarks[8];
            const middle = landmarks[12];
            const ring = landmarks[16];
            const pinky = landmarks[20];
            const wrist = landmarks[0];
            
            // Calculate key distances
            const thumbIndexDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            const fingersToWrist = [];
            
            for (let i = 8; i <= 20; i += 4) {
                fingersToWrist.push(Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            }
            
            // Gesture detection with confidence
            const avgFingerDist = fingersToWrist.reduce((a, b) => a + b) / fingersToWrist.length;
            
            // Fist detection
            const fistConfidence = Math.max(0, 1 - (avgFingerDist / CONFIG.FIST_THRESHOLD));
            hand.gestures.fist = {
                active: fistConfidence > CONFIG.GESTURE_CONFIDENCE,
                confidence: fistConfidence
            };
            
            // Open hand (opposite of fist)
            hand.gestures.open = {
                active: fistConfidence < 0.3,
                confidence: 1 - fistConfidence
            };
            
            // Pinch detection
            const pinchConfidence = Math.max(0, 1 - (thumbIndexDist / CONFIG.PINCH_THRESHOLD));
            hand.gestures.pinch = {
                active: pinchConfidence > CONFIG.GESTURE_CONFIDENCE,
                confidence: pinchConfidence
            };
            
            // Two fingers (simple detection)
            const middleRingDist = Math.hypot(middle.x - ring.x, middle.y - ring.y);
            const twoFingerConfidence = thumbIndexDist < 0.08 && middleRingDist > 0.12 ? 0.8 : 0;
            hand.gestures.twoFingers = {
                active: twoFingerConfidence > CONFIG.GESTURE_CONFIDENCE,
                confidence: twoFingerConfidence
            };
        }

        // ========== UPDATE EARTH CONTROL (OPTIMIZED) ==========
        function updateEarthControl(deltaTime) {
            // Auto-rotation when no hand
            if (!hand.detected || hand.confidence < 0.3) {
                earthGroup.rotation.y += CONFIG.AUTO_ROTATION;
                hand.inertia.x *= CONFIG.INERTIA_DECAY;
                hand.inertia.y *= CONFIG.INERTIA_DECAY;
                return;
            }
            
            // Calculate control input from hand
            const moveX = (hand.smoothed.x - 0.5) * 2;
            const moveY = (hand.smoothed.y - 0.5) * 2;
            
            // Apply deadzone
            const deadzone = CONFIG.DEADZONE;
            const inputX = Math.abs(moveX) > deadzone ? moveX : 0;
            const inputY = Math.abs(moveY) > deadzone ? moveY : 0;
            
            // ROTATION CONTROL
            if (hand.gestures.open.active && hand.gestures.open.confidence > 0.7) {
                const rotationSpeed = CONFIG.ROTATION_SENSITIVITY * deltaTime;
                hand.inertia.x += inputY * rotationSpeed;
                hand.inertia.y += -inputX * rotationSpeed;
            }
            
            // ZOOM CONTROL
            if (hand.gestures.fist.active && hand.gestures.fist.confidence > 0.7) {
                // Zoom out with fist
                hand.inertia.z -= CONFIG.ZOOM_SENSITIVITY;
            } else if (hand.gestures.pinch.active && hand.gestures.pinch.confidence > 0.7) {
                // Zoom in with pinch
                hand.inertia.z += CONFIG.ZOOM_SENSITIVITY;
            }
            
            // TWO FINGER ACTION (reset)
            if (hand.gestures.twoFingers.active && hand.gestures.twoFingers.confidence > 0.7) {
                if (!hand.lastTwoFingers) {
                    // Reset view
                    cameraTarget.distance = CONFIG.CAMERA_DISTANCE;
                    cameraTarget.rotation.x = 0;
                    cameraTarget.rotation.y = 0;
                    hand.inertia.x = 0;
                    hand.inertia.y = 0;
                    hand.inertia.z = 0;
                }
                hand.lastTwoFingers = true;
            } else {
                hand.lastTwoFingers = false;
            }
            
            // Apply inertia with decay
            hand.inertia.x *= CONFIG.INERTIA_DECAY;
            hand.inertia.y *= CONFIG.INERTIA_DECAY;
            hand.inertia.z *= CONFIG.INERTIA_DECAY;
            
            // Apply rotation to Earth
            earthGroup.rotation.x += hand.inertia.x;
            earthGroup.rotation.y += hand.inertia.y;
            
            // Apply zoom to camera
            cameraTarget.distance += hand.inertia.z;
            cameraTarget.distance = Math.max(CONFIG.CAMERA_MIN, Math.min(CONFIG.CAMERA_MAX, cameraTarget.distance));
            
            // Smooth camera movement
            camera.position.z += (cameraTarget.distance - camera.position.z) * CONFIG.CAMERA_SMOOTH;
            
            // Rotate clouds
            clouds.rotation.y += deltaTime * 0.0005;
        }

        // ========== DEMO MODE ==========
        function startDemoMode() {
            // Auto-rotation for demo
            setInterval(() => {
                if (!hand.detected) {
                    earthGroup.rotation.y += CONFIG.AUTO_ROTATION * 2;
                    camera.position.z = 16 + Math.sin(performance.now() * 0.001) * 2;
                }
            }, 16);
        }

        // ========== UPDATE PERFORMANCE ==========
        function updatePerformance(now) {
            frameCount++;
            
            if (now >= lastFPSUpdate + 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFPSUpdate));
                document.getElementById('fpsCounter').textContent = fps;
                
                // Update stability
                SYSTEM.performance.fpsHistory.push(fps);
                if (SYSTEM.performance.fpsHistory.length > 30) {
                    SYSTEM.performance.fpsHistory.shift();
                }
                
                const avgFPS = SYSTEM.performance.fpsHistory.reduce((a, b) => a + b) / SYSTEM.performance.fpsHistory.length;
                SYSTEM.performance.stability = Math.min(100, (avgFPS / 60) * 100);
                
                frameCount = 0;
                lastFPSUpdate = now;
            }
        }

        // ========== UPDATE CONNECTION STATUS ==========
        function updateConnectionStatus(status) {
            const element = document.getElementById('connectionStatus');
            if (element) {
                element.textContent = status;
                
                // Visual feedback
                const dot = document.querySelector('.connection-dot');
                if (status === "TRACKING") {
                    dot.style.background = "#00ff88";
                } else if (status === "DEMO MODE") {
                    dot.style.background = "#ffaa00";
                } else {
                    dot.style.background = "#ff4444";
                }
            }
        }

        // ========== ANIMATION LOOP (OPTIMIZED) ==========
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            // Update Earth control
            updateEarthControl(deltaTime);
            
            // Update performance
            updatePerformance(currentTime);
            
            // Camera look at Earth
            camera.lookAt(0, 0, 0);
            
            // Render
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE (OPTIMIZED) ==========
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========== INITIALIZE SYSTEM ==========
        async function init() {
            console.log("ðŸš€ Initializing Optimized Earth Control System v4.0");
            
            // Initialize Three.js
            initThreeJS();
            
            // Initialize Camera (non-blocking)
            setTimeout(() => initCamera(), 100);
            
            // Start animation
            animate(0);
            
            // Add optimized event listeners
            window.addEventListener('resize', onResize, { passive: true });
            
            // Performance monitoring
            setInterval(() => {
                if (SYSTEM.performance.stability < 80) {
                    console.warn("Performance warning: ", SYSTEM.performance.stability.toFixed(1) + "%");
                }
            }, 5000);
        }

        // ========== START EVERYTHING ==========
        window.addEventListener('load', init);
    </script>
</body>
</html>
