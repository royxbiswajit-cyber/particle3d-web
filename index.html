<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Hand Tracking Particles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        #container {
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #webcamContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 225px;
            border: 3px solid #00ff88;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 25px #00ff88;
        }
        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 10, 20, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #0088ff;
            max-width: 320px;
            backdrop-filter: blur(5px);
        }
        .title {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 22px;
            text-shadow: 0 0 15px #00ffff;
        }
        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        .mode-btn {
            padding: 12px 5px;
            background: linear-gradient(135deg, #0066cc, #6600cc);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 200, 255, 0.5);
        }
        .mode-btn.active {
            background: linear-gradient(135deg, #00ff88, #0088ff);
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px #00ff88;
        }
        .control-panel {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 30, 60, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .control-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .control-label {
            width: 120px;
            color: #88ffff;
            font-size: 14px;
        }
        .slider-container {
            flex: 1;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, #0066cc, #cc00cc);
            border-radius: 3px;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 10px #00ff88;
        }
        .value-display {
            width: 50px;
            text-align: right;
            color: #ff88ff;
            font-weight: bold;
            font-size: 14px;
        }
        #handVisual {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        #handCircle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 30px #00ff88;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 0.4; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        #gestureEmoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            filter: drop-shadow(0 0 10px white);
        }
        #statusPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffaa00;
            max-width: 350px;
            font-size: 13px;
        }
        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        .status-label {
            color: #88ff88;
        }
        .status-value {
            color: #ffaa00;
            font-weight: bold;
        }
        .gesture-help {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 30, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff00ff;
            max-width: 250px;
        }
        .help-item {
            margin: 8px 0;
            font-size: 12px;
        }
        .particle-count {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #debugInfo {
            position: absolute;
            top: 50px;
            right: 10px;
            color: #ff8888;
            font-size: 11px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="mainCanvas"></canvas>
        
        <div id="webcamContainer">
            <video id="webcam" autoplay playsinline muted></video>
        </div>
        
        <div id="ui">
            <div class="title">üéÆ PARTICLE CONTROL</div>
            
            <div class="mode-buttons">
                <button class="mode-btn active" onclick="setMode('follow')">üëã FOLLOW</button>
                <button class="mode-btn" onclick="setMode('attract')">‚úä ATTRACT</button>
                <button class="mode-btn" onclick="setMode('repel')">üñêÔ∏è REPEL</button>
                <button class="mode-btn" onclick="setMode('swirl')">üåÄ SWIRL</button>
                <button class="mode-btn" onclick="setMode('rainbow')">üåà RAINBOW</button>
                <button class="mode-btn" onclick="setMode('explode')">üí• EXPLODE</button>
            </div>
            
            <div class="control-panel">
                <div class="control-row">
                    <div class="control-label">Particles:</div>
                    <div class="slider-container">
                        <input type="range" id="particleSlider" min="1000" max="15000" value="5000" step="500">
                    </div>
                    <div class="value-display" id="particleValue">5000</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">Speed:</div>
                    <div class="slider-container">
                        <input type="range" id="speedSlider" min="0.1" max="3.0" value="1.5" step="0.1">
                    </div>
                    <div class="value-display" id="speedValue">1.5</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">Size:</div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="0.5" max="5.0" value="2.0" step="0.1">
                    </div>
                    <div class="value-display" id="sizeValue">2.0</div>
                </div>
            </div>
        </div>
        
        <div id="handVisual">
            <div id="handCircle"></div>
            <div id="gestureEmoji">üëã</div>
        </div>
        
        <div class="gesture-help">
            <div style="color:#ff00ff; font-weight:bold; margin-bottom:8px;">HAND GESTURES:</div>
            <div class="help-item">üëã Open Hand = Follow Mode</div>
            <div class="help-item">‚úä Closed Fist = Attract</div>
            <div class="help-item">üñêÔ∏è Palm Open = Repel</div>
            <div class="help-item">‚úåÔ∏è Peace Sign = Swirl</div>
            <div class="help-item">üëç Thumbs Up = Rainbow</div>
            <div class="help-item">üëÜ Pointing = Explode</div>
        </div>
        
        <div id="statusPanel">
            <div class="status-item">
                <span class="status-label">Camera:</span>
                <span class="status-value" id="camStatus">OFF</span>
            </div>
            <div class="status-item">
                <span class="status-label">Hand Detected:</span>
                <span class="status-value" id="handStatus">NO</span>
            </div>
            <div class="status-item">
                <span class="status-label">Gesture:</span>
                <span class="status-value" id="gestureStatus">NONE</span>
            </div>
            <div class="status-item">
                <span class="status-label">Confidence:</span>
                <span class="status-value" id="confValue">0%</span>
            </div>
            <div class="status-item">
                <span class="status-label">FPS:</span>
                <span class="status-value" id="fpsValue">0</span>
            </div>
        </div>
        
        <div class="particle-count" id="particleCounter">‚ú® 5000 ‚ú®</div>
        <div id="debugInfo"></div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <!-- Camera utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ========== MAIN VARIABLES ==========
        let scene, camera, renderer;
        let particleSystem;
        let particles = [];
        let currentMode = 'follow';
        let particleCount = 5000;
        let particleSize = 2.0;
        let globalSpeed = 1.5;
        let time = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Hand tracking
        let handDetector;
        let handX = 0.5, handY = 0.5;
        let handZ = 0;
        let lastHandX = 0.5, lastHandY = 0.5;
        let handVelocity = { x: 0, y: 0 };
        let currentGesture = 'none';
        let gestureConfidence = 0;
        let handVisible = false;
        
        // Smoothing
        let smoothHandX = 0.5;
        let smoothHandY = 0.5;
        const smoothingFactor = 0.2;

        // ========== INITIALIZE THREE.JS ==========
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 100);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 35);
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('mainCanvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            
            // Advanced lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Point light that follows hand
            const pointLight = new THREE.PointLight(0x00ffff, 2, 50);
            pointLight.position.set(0, 0, 20);
            scene.add(pointLight);
            
            updateStatus('camera', 'INIT');
            updateStatus('hand', 'WAITING');
        }

        // ========== CREATE PARTICLE SYSTEM ==========
        function createParticleSystem() {
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
            }
            
            particles = [];
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // Create spherical distribution
                const radius = Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                particles.push({
                    x, y, z,
                    vx: 0, vy: 0, vz: 0,
                    originalX: x,
                    originalY: y,
                    originalZ: z,
                    size: Math.random() * 0.8 + 0.5,
                    color: new THREE.Color()
                });
                
                // Set initial positions
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Set initial colors based on position
                const hue = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);
                particles[i].color.setHSL(hue, 0.9, 0.5);
                
                colors[i * 3] = particles[i].color.r;
                colors[i * 3 + 1] = particles[i].color.g;
                colors[i * 3 + 2] = particles[i].color.b;
                
                sizes[i] = particles[i].size * particleSize;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            document.getElementById('particleCounter').textContent = `‚ú® ${particleCount.toLocaleString()} ‚ú®`;
            updateStatus('hand', `${particleCount} particles created`);
        }

        // ========== INITIALIZE HAND TRACKING ==========
        async function initHandTracking() {
            try {
                updateStatus('camera', 'STARTING');
                
                // Get camera access
                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 60 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                await video.play();
                
                updateStatus('camera', 'ON');
                
                // Initialize MediaPipe Hands
                handDetector = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                handDetector.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });
                
                handDetector.onResults(onHandResults);
                
                // Start camera
                const camera = new Camera(video, {
                    onFrame: async () => {
                        if (handDetector) {
                            await handDetector.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                updateStatus('hand', 'READY - Show your hand!');
                
            } catch (error) {
                console.error('Hand tracking error:', error);
                updateStatus('camera', 'ERROR');
                updateStatus('hand', 'Using mouse controls');
                setupMouseControls();
            }
        }

        // ========== PROCESS HAND RESULTS ==========
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const handedness = results.multiHandedness[0];
                
                // Get palm center (landmarks 0 and 9)
                const wrist = landmarks[0];
                const middleBase = landmarks[9];
                
                handX = (wrist.x + middleBase.x) / 2;
                handY = (wrist.y + middleBase.y) / 2;
                handZ = (wrist.z + middleBase.z) / 2;
                
                // Smooth hand position
                smoothHandX = smoothHandX + (handX - smoothHandX) * smoothingFactor;
                smoothHandY = smoothHandY + (handY - smoothHandY) * smoothingFactor;
                
                // Calculate velocity
                handVelocity.x = (smoothHandX - lastHandX) * 100;
                handVelocity.y = (smoothHandY - lastHandY) * 100;
                lastHandX = smoothHandX;
                lastHandY = smoothHandY;
                
                // Detect gesture
                detectGesture(landmarks);
                
                // Update hand visual
                updateHandVisual();
                handVisible = true;
                
                updateStatus('hand', 'DETECTED');
                updateStatus('confidence', Math.round(handedness.score * 100) + '%');
                updateStatus('gesture', currentGesture.toUpperCase());
                
            } else {
                handVisible = false;
                document.getElementById('handVisual').style.display = 'none';
                updateStatus('hand', 'NO HAND');
                updateStatus('gesture', 'NONE');
            }
        }

        // ========== GESTURE DETECTION ==========
        function detectGesture(landmarks) {
            const fingerTips = [4, 8, 12, 16, 20];
            const fingerPips = [3, 7, 11, 15, 19];
            
            let extendedFingers = 0;
            let fingerStates = [];
            
            // Check each finger
            for (let i = 0; i < 5; i++) {
                const tip = landmarks[fingerTips[i]];
                const pip = landmarks[fingerPips[i]];
                
                // For thumb (check x position)
                if (i === 0) {
                    if (tip.x < pip.x - 0.05) {
                        extendedFingers++;
                        fingerStates.push(true);
                    } else {
                        fingerStates.push(false);
                    }
                } 
                // For other fingers (check y position)
                else {
                    if (tip.y < pip.y - 0.03) {
                        extendedFingers++;
                        fingerStates.push(true);
                    } else {
                        fingerStates.push(false);
                    }
                }
            }
            
            // Determine gesture
            let newGesture = 'none';
            let emoji = 'üëã';
            
            if (extendedFingers === 0) {
                newGesture = 'fist';
                emoji = '‚úä';
                currentMode = 'attract';
            } else if (extendedFingers === 5) {
                newGesture = 'palm';
                emoji = 'üñêÔ∏è';
                currentMode = 'repel';
            } else if (extendedFingers === 2 && fingerStates[1] && fingerStates[2]) {
                newGesture = 'peace';
                emoji = '‚úåÔ∏è';
                currentMode = 'swirl';
            } else if (extendedFingers === 1 && fingerStates[0]) {
                newGesture = 'thumb';
                emoji = 'üëç';
                currentMode = 'rainbow';
            } else if (extendedFingers === 1 && fingerStates[1]) {
                newGesture = 'point';
                emoji = 'üëÜ';
                currentMode = 'explode';
            } else {
                newGesture = 'open';
                emoji = 'üëã';
                currentMode = 'follow';
            }
            
            // Update if gesture changed
            if (newGesture !== currentGesture) {
                currentGesture = newGesture;
                document.getElementById('gestureEmoji').textContent = emoji;
                
                // Update mode button
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                const modeBtn = document.querySelector(`.mode-btn[onclick*="${currentMode}"]`);
                if (modeBtn) modeBtn.classList.add('active');
            }
        }

        // ========== UPDATE HAND VISUAL ==========
        function updateHandVisual() {
            const handVisual = document.getElementById('handVisual');
            const screenX = smoothHandX * window.innerWidth;
            const screenY = smoothHandY * window.innerHeight;
            
            handVisual.style.left = screenX + 'px';
            handVisual.style.top = screenY + 'px';
            handVisual.style.display = 'block';
            
            // Scale based on hand distance (z)
            const scale = 1 + handZ * 2;
            handVisual.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Color based on mode
            const colors = {
                'follow': '#00ffff',
                'attract': '#ff0000',
                'repel': '#00ff00',
                'swirl': '#ff00ff',
                'rainbow': '#ffff00',
                'explode': '#ff8800'
            };
            
            document.getElementById('handCircle').style.borderColor = colors[currentMode] || '#00ffff';
            document.getElementById('handCircle').style.boxShadow = `0 0 30px ${colors[currentMode] || '#00ffff'}`;
        }

        // ========== APPLY HAND PHYSICS ==========
        function applyHandPhysics() {
            if (!handVisible || !particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            // Convert hand position to 3D space
            const hand3DX = (smoothHandX - 0.5) * 40;
            const hand3DY = -(smoothHandY - 0.5) * 30;
            
            // Update camera to follow hand
            camera.position.x += (hand3DX - camera.position.x) * 0.15;
            camera.position.y += (hand3DY - camera.position.y) * 0.15;
            camera.lookAt(hand3DX * 0.7, hand3DY * 0.7, 0);
            
            // Update point light
            const pointLight = scene.children.find(c => c.type === 'PointLight');
            if (pointLight) {
                pointLight.position.set(hand3DX, hand3DY, 10);
                
                // Light color based on mode
                const lightColors = {
                    'follow': 0x00ffff,
                    'attract': 0xff0000,
                    'repel': 0x00ff00,
                    'swirl': 0xff00ff,
                    'rainbow': 0xffff00,
                    'explode': 0xff8800
                };
                pointLight.color.setHex(lightColors[currentMode] || 0x00ffff);
            }
            
            // Apply particle effects based on mode
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // Calculate distance to hand
                const dx = hand3DX - p.x;
                const dy = hand3DY - p.y;
                const dz = -p.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                // Apply different effects based on mode
                switch(currentMode) {
                    case 'follow':
                        // Gentle attraction
                        const followStrength = 0.01 * globalSpeed;
                        p.vx += dx * followStrength / (distance + 10);
                        p.vy += dy * followStrength / (distance + 10);
                        p.vz += dz * followStrength / (distance + 10);
                        break;
                        
                    case 'attract':
                        // Strong attraction
                        const attractStrength = 0.03 * globalSpeed;
                        p.vx += dx * attractStrength / (distance + 5);
                        p.vy += dy * attractStrength / (distance + 5);
                        p.vz += dz * attractStrength / (distance + 5);
                        break;
                        
                    case 'repel':
                        // Repulsion
                        const repelStrength = 0.02 * globalSpeed;
                        p.vx -= dx * repelStrength / (distance * distance + 1);
                        p.vy -= dy * repelStrength / (distance * distance + 1);
                        p.vz -= dz * repelStrength / (distance * distance + 1);
                        break;
                        
                    case 'swirl':
                        // Swirling motion
                        const swirlStrength = 0.05 * globalSpeed;
                        const angle = Math.atan2(dy, dx);
                        p.vx += Math.cos(angle + Math.PI/2) * swirlStrength;
                        p.vy += Math.sin(angle + Math.PI/2) * swirlStrength;
                        p.vz += Math.sin(time + i * 0.01) * 0.1;
                        break;
                        
                    case 'rainbow':
                        // Color cycling
                        const hue = (time * 0.5 + i * 0.001) % 1;
                        p.color.setHSL(hue, 0.9, 0.5);
                        colors[i * 3] = p.color.r;
                        colors[i * 3 + 1] = p.color.g;
                        colors[i * 3 + 2] = p.color.b;
                        break;
                        
                    case 'explode':
                        // Explosion from hand
                        if (distance < 10) {
                            const explodeStrength = 0.1 * globalSpeed;
                            p.vx += dx * explodeStrength;
                            p.vy += dy * explodeStrength;
                            p.vz += Math.random() * 2 - 1;
                        }
                        break;
                }
                
                // Apply velocity
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                // Apply friction
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.vz *= 0.95;
                
                // Return to original position slowly
                if (currentMode === 'follow') {
                    const returnStrength = 0.005 * globalSpeed;
                    p.vx += (p.originalX - p.x) * returnStrength;
                    p.vy += (p.originalY - p.y) * returnStrength;
                    p.vz += (p.originalZ - p.z) * returnStrength;
                }
                
                // Update position in buffer
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            }
            
            // Mark buffers for update
            particleSystem.geometry.attributes.position.needsUpdate = true;
            if (currentMode === 'rainbow') {
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }
        }

        // ========== MOUSE CONTROLS (FALLBACK) ==========
        function setupMouseControls() {
            let mouseX = 0.5, mouseY = 0.5;
            let mouseDown = false;
            let rightDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX / window.innerWidth;
                mouseY = e.clientY / window.innerHeight;
                smoothHandX = mouseX;
                smoothHandY = mouseY;
                handVisible = true;
                updateHandVisual();
                updateStatus('hand', 'MOUSE');
                updateStatus('gesture', 'MOUSE CONTROL');
            });
            
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    mouseDown = true;
                    currentMode = 'attract';
                    currentGesture = 'fist';
                } else if (e.button === 2) {
                    rightDown = true;
                    currentMode = 'repel';
                    currentGesture = 'palm';
                }
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
                rightDown = false;
                currentMode = 'follow';
                currentGesture = 'open';
            });
            
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case '1': currentMode = 'follow'; break;
                    case '2': currentMode = 'attract'; break;
                    case '3': currentMode = 'repel'; break;
                    case '4': currentMode = 'swirl'; break;
                    case '5': currentMode = 'rainbow'; break;
                    case '6': currentMode = 'explode'; break;
                }
                
                // Update mode button
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                const modeBtn = document.querySelector(`.mode-btn[onclick*="${currentMode}"]`);
                if (modeBtn) modeBtn.classList.add('active');
            });
        }

        // ========== UI CONTROLS ==========
        function setupUIControls() {
            // Particle count slider
            const particleSlider = document.getElementById('particleSlider');
            const particleValue = document.getElementById('particleValue');
            particleSlider.addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
                particleValue.textContent = particleCount.toLocaleString();
                createParticleSystem();
            });
            
            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                globalSpeed = parseFloat(e.target.value);
                speedValue.textContent = globalSpeed.toFixed(1);
            });
            
            // Size slider
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            sizeSlider.addEventListener('input', (e) => {
                particleSize = parseFloat(e.target.value);
                sizeValue.textContent = particleSize.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = particleSize;
                    const sizes = particleSystem.geometry.attributes.size.array;
                    for (let i = 0; i < particles.length; i++) {
                        sizes[i] = particles[i].size * particleSize;
                    }
                    particleSystem.geometry.attributes.size.needsUpdate = true;
                }
            });
            
            // Mode buttons
            window.setMode = function(mode) {
                currentMode = mode;
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            };
        }

        // ========== UPDATE STATUS ==========
        function updateStatus(type, value) {
            const now = Date.now();
            
            switch(type) {
                case 'camera':
                    document.getElementById('camStatus').textContent = value;
                    break;
                case 'hand':
                    document.getElementById('handStatus').textContent = value;
                    break;
                case 'gesture':
                    document.getElementById('gestureStatus').textContent = value;
                    break;
                case 'confidence':
                    document.getElementById('confValue').textContent = value;
                    break;
                case 'fps':
                    document.getElementById('fpsValue').textContent = value;
                    break;
            }
        }

        // ========== UPDATE FPS ==========
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            
            if (now >= lastFpsUpdate + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                updateStatus('fps', fps);
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016 * globalSpeed;
            updateFPS();
            
            // Apply hand physics
            applyHandPhysics();
            
            // Additional effects
            if (particleSystem) {
                // Gentle system rotation
                particleSystem.rotation.y += 0.001 * globalSpeed;
                particleSystem.rotation.x += 0.0005 * globalSpeed;
                
                // Particle breathing effect
                const sizes = particleSystem.geometry.attributes.size.array;
                if (currentMode !== 'rainbow') {
                    for (let i = 0; i < particles.length; i++) {
                        const pulse = Math.sin(time + i * 0.01) * 0.3 + 0.7;
                        sizes[i] = particles[i].size * particleSize * pulse;
                    }
                    particleSystem.geometry.attributes.size.needsUpdate = true;
                }
            }
            
            renderer.render(scene, camera);
        }

        // ========== WINDOW RESIZE ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== CAMERA UTILS (MediaPipe) ==========
        class Camera {
            constructor(video, config) {
                this.video = video;
                this.config = config;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
            }
            
            async start() {
                this.canvas.width = this.config.width;
                this.canvas.height = this.config.height;
                
                const loop = async () => {
                    if (this.video.readyState >= this.video.HAVE_ENOUGH_DATA) {
                        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                        if (this.config.onFrame) {
                            await this.config.onFrame();
                        }
                    }
                    requestAnimationFrame(loop);
                };
                loop();
            }
        }

        // ========== INITIALIZE EVERYTHING ==========
        async function init() {
            try {
                console.log("üöÄ Initializing...");
                initThreeJS();
                setupUIControls();
                createParticleSystem();
                await initHandTracking();
                animate();
                
                console.log("‚úÖ System ready!");
                
            } catch (error) {
                console.error("‚ùå Initialization error:", error);
                updateStatus('camera', 'ERROR');
                updateStatus('hand', 'Check console');
            }
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
